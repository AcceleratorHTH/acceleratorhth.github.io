---
title: GoogleCTF 2023
description: CTF-Crypto
author: Pr0pylTh10ur4C1L
date: 2023-06-26 22:39:00 +0700
categories: [Capture The Flag]
tags: [Cryptography]
math: true
mermaid: true
---

## LEAST COMMON GENOMINATOR?

Someone used this program to send me an encrypted message but I can't read it! It uses something called an LCG, do you know what it is? I dumped the first six consecutive values generated from it but what do I do with it?!

Attachment:

- dump.txt
```
2166771675595184069339107365908377157701164485820981409993925279512199123418374034275465590004848135946671454084220731645099286746251308323653144363063385
6729272950467625456298454678219613090467254824679318993052294587570153424935267364971827277137521929202783621553421958533761123653824135472378133765236115
2230396903302352921484704122705539403201050490164649102182798059926343096511158288867301614648471516723052092761312105117735046752506523136197227936190287
4578847787736143756850823407168519112175260092601476810539830792656568747136604250146858111418705054138266193348169239751046779010474924367072989895377792
7578332979479086546637469036948482551151240099803812235949997147892871097982293017256475189504447955147399405791875395450814297264039908361472603256921612
2550420443270381003007873520763042837493244197616666667768397146110589301602119884836605418664463550865399026934848289084292975494312467018767881691302197
```

- flag.txt
```
Lï¿½hyï¿½kKï¿½? ï¿½z7	ï¿½ï¿½nï¿½ï¿½ï¿½ï¿½ï¿½ZNï¿½ï¿½ï¿½zï¿½ï¿½ï¿½:pï¿½ï¿½%TÛ°'Iï¿½mLi6ï¿½ ï¿½%ï¿½ï¿½*ï¿½Jï¿½ï¿½ï¿½hnTï¿½ï¿½<<9ï¿½ï¿½voï¿½ï¿½ï¿½3?pï¿½`Ö¦Tï¿½mÖ±ÑjQï¿½ï¿½Zï¿½ï¿½)Gï¿½ï¿½O8;ï¿½'ï¿½2ï¿½ï¿½ï¿½)yï¿½;ï¿½ï¿½C~;ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½X{ï¿½Mï¿½dï¿½ï¿½7ï¿½ï¿½,Kï¿½Bï¿½ï¿½p=5ï¿½ï¿½A
```

- generate.py
```python
from secret import config
from Crypto.PublicKey import RSA
from Crypto.Util.number import bytes_to_long, isPrime

class LCG:
    lcg_m = config.m
    lcg_c = config.c
    lcg_n = config.n

    def __init__(self, lcg_s):
        self.state = lcg_s

    def next(self):
        self.state = (self.state * self.lcg_m + self.lcg_c) % self.lcg_n
        return self.state

if __name__ == '__main__':

    assert 4096 % config.it == 0
    assert config.it == 8
    assert 4096 % config.bits == 0
    assert config.bits == 512

    # Find prime value of specified bits a specified amount of times
    seed = 211286818345627549183608678726370412218029639873054513839005340650674982169404937862395980568550063504804783328450267566224937880641772833325018028629959635
    lcg = LCG(seed)
    primes_arr = []
    
    dump = True
    items = 0
    dump_file = open("dumptest.txt", "w")

    primes_n = 1
    while True:
        for i in range(config.it):
            while True:
                prime_candidate = lcg.next()
                if dump:
                    dump_file.write(str(prime_candidate) + '\n')
                    items += 1
                    if items == 6:
                        dump = False
                        dump_file.close()
                if not isPrime(prime_candidate):
                    continue
                elif prime_candidate.bit_length() != config.bits:
                    continue
                else:
                    primes_n *= prime_candidate
                    primes_arr.append(prime_candidate)
                    break
        
        # Check bit length
        if primes_n.bit_length() > 4096:
            print("bit length", primes_n.bit_length())
            primes_arr.clear()
            primes_n = 1
            continue
        else:
            break


    # Create public key 'n'
    n = 1
    for j in primes_arr:
        n *= j
    print("[+] Public Key: ", n)
    print("[+] size: ", n.bit_length(), "bits")

    # Calculate totient 'Phi(n)'
    phi = 1
    for k in primes_arr:
        phi *= (k - 1)

    # Calculate private key 'd'
    d = pow(config.e, -1, phi)

    # Generate Flag
    assert config.flag.startswith(b"CTF{")
    assert config.flag.endswith(b"}")
    enc_flag = bytes_to_long(config.flag)
    assert enc_flag < n

    # Encrypt Flag
    _enc = pow(enc_flag, config.e, n)

    with open ("flag.txt", "wb") as flag_file:
        flag_file.write(_enc.to_bytes(n.bit_length(), "little"))

    # Export RSA Key
    rsa = RSA.construct((n, config.e))
    with open ("public.pem", "w") as pub_file:
        pub_file.write(rsa.exportKey().decode())
```
- public.pem
```
-----BEGIN PUBLIC KEY-----
MIICITANBgkqhkiG9w0BAQEFAAOCAg4AMIICCQKCAgACnR8r4GemZPmX2+zLsBgz
qHanMd0pbEGFRRldNezYX9A3HT99peociEbEMUnUaVWuDbzHJX7drG8s/exQW4XF
fE5lGy+D0gSkJfQS1komUxic6iWH/1bZnU6rWFJlpbIzy/3IMx4QIx5cbOA0SsLu
AomMEi4ZERGLxm2ta7ZZZuEYVYIa9/mrlXYkTgi1fxLguT35ykHNk5Rm8e8Q8KF/
V2pQ3CQIQYZra2WLGNsxOXW7FLttmMyzgi4WQjLE/SVMs7Th5lGkjmXoQpMcc0Zh
kL3H0vMHWtQeclqsE+QXgAUQFshiSb0auf69y/H+R+qJCO0jRgBz3OVudSx91oSB
GaF7DTfFu3LsgJvMDRAdhPgdlLLzlR0PldVq1jKwjs1dWce2R5r4B0dnXqPrxLuu
A/WNp3ni3jp6AL2y7MKn2AylPUEr+/fQ6+B33wuIHcZiXHdYYPvemehtCf1WCV4Q
/C10Q3E6PK6R+dncE7ZUg0U3qnA84rAZUwweGLUD2yXngHMxDLLRv44Uv28XFvl3
5kFrlJhIhxtx/Fon70EKNboDCT8UXJ5ZlMyt47WBmYGp7FZbafbH6coLAQr1LQCy
HCJYimu7lXr9eGYixE93xXHJ3KIJPaZGmhW3qbj3B8ZxrIvGjkZtHqiw+OCNj343
Q44DknQ8F3CwBmZUmBxZSQIDAQAB
-----END PUBLIC KEY-----
```

Problem analysis:

á»ž Ä‘Ã¢y thÃ¬ Ä‘á» bÃ i cÃ³ Ä‘á» cáº­p tá»›i má»™t khÃ¡i niá»‡m lÃ  LCG. Sau khi mÃ¬nh thá»­ tra theo tÃªn challenge nÃ y thÃ¬ cÃ³ váº» khÃ´ng Ä‘Ãºng. TÃ¬m tÃ²i má»™t há»“i thÃ¬ mÃ¬nh Ä‘Ã£ tÃ¬m ra nÃ³ lÃ  â€œLinear congruential generatorâ€, má»™t thuáº­t toÃ¡n sinh sá»‘ giáº£ ngáº«u nhiÃªn (Pseudo Random Number GenerationÂ - PRNG)

![image](https://github.com/AcceleratorHTH/CEA201/assets/86862725/25a62ab0-c392-4434-9f4a-923fcda4ea63)

Vá» cÆ¡ báº£n thÃ¬ thuáº­t toÃ¡n nÃ y sáº½ chá»‰ sá»­ dá»¥ng má»™t hÃ m Ä‘á»‡ quy:

Xn+1= (aXn+ c) mod m

Trong Ä‘Ã³:

- m, 0 < m: mÃ´ Ä‘un â€œmodulusâ€, thÆ°á»ng lÃ  má»™t sá»‘ Ä‘á»§ lá»›n, nhÆ° 2^32, 2^31â€“ 1, 2^48, 2^64
- a, 0 < a < m: Háº±ng sá»‘ nhÃ¢n â€œmultiplierâ€
- c, 0 â‰¤ c < m: Háº±ng sá»‘ cá»™ng thÃªmÂ â€œincrementâ€
- X0, 0 â‰¤ X0 < m : â€œseedâ€, giÃ¡ trá»‹ khá»Ÿi táº¡o

Chu ká»³ cá»§a LCG lá»›n nháº¥t lÃ  m, vÃ  Ä‘á»ƒ LCG sinh ra táº¥t cáº£ cÃ¡c giÃ¡ trá»‹ trong chu ká»³ vá»›i má»i giÃ¡ trá»‹ khá»Ÿi táº¡o (full-period) thÃ¬ sáº½ cáº§n nhá»¯ng Ä‘iá»u kiá»‡n rÃ ng buá»™c sau:

- mÂ vÃ Â cÂ lÃ  nguyÃªn tá»‘ cÃ¹ng nhau.
- a-1 chia háº¿t cho má»i thá»«a sá»‘ nguyÃªn tá»‘ cá»§aÂ m
- a-1Â chia háº¿t cho 4 náº¿uÂ mÂ chia háº¿t cho 4.

CÃ¡c báº¡n cÃ³ thá»ƒ xem thÃªm táº¡i Ä‘Ã¢y:

<https://en.wikipedia.org/wiki/Linear_congruential_generator>

NhÆ°ng Ä‘á»‘ng nÃ y thÃ¬ liÃªn quan gÃ¬ Ä‘áº¿n challenge? MÃ¬nh thá»­ má»Ÿ code file **generate.py**

``` python
from secret import config
from Crypto.PublicKey import RSA
from Crypto.Util.number import bytes_to_long, isPrime

class LCG:
    lcg_m = config.m
    lcg_c = config.c
    lcg_n = config.n

    def __init__(self, lcg_s):
        self.state = lcg_s

    def next(self):
        self.state = (self.state * self.lcg_m + self.lcg_c) % self.lcg_n
        return self.state

if __name__ == '__main__':

    assert 4096 % config.it == 0
    assert config.it == 8
    assert 4096 % config.bits == 0
    assert config.bits == 512

    # Find prime value of specified bits a specified amount of times
    seed = 211286818345627549183608678726370412218029639873054513839005340650674982169404937862395980568550063504804783328450267566224937880641772833325018028629959635
    lcg = LCG(seed)
    primes_arr = []
    
    dump = True
    items = 0
    dump_file = open("dumptest.txt", "w")

    primes_n = 1
    while True:
        for i in range(config.it):
            while True:
                prime_candidate = lcg.next()
                if dump:
                    dump_file.write(str(prime_candidate) + '\n')
                    items += 1
                    if items == 6:
                        dump = False
                        dump_file.close()
                if not isPrime(prime_candidate):
                    continue
                elif prime_candidate.bit_length() != config.bits:
                    continue
                else:
                    primes_n *= prime_candidate
                    primes_arr.append(prime_candidate)
                    break
        
        # Check bit length
        if primes_n.bit_length() > 4096:
            print("bit length", primes_n.bit_length())
            primes_arr.clear()
            primes_n = 1
            continue
        else:
            break


    # Create public key 'n'
    n = 1
    for j in primes_arr:
        n *= j
    print("[+] Public Key: ", n)
    print("[+] size: ", n.bit_length(), "bits")

    # Calculate totient 'Phi(n)'
    phi = 1
    for k in primes_arr:
        phi *= (k - 1)

    # Calculate private key 'd'
    d = pow(config.e, -1, phi)

    # Generate Flag
    assert config.flag.startswith(b"CTF{")
    assert config.flag.endswith(b"}")
    enc_flag = bytes_to_long(config.flag)
    assert enc_flag < n

    # Encrypt Flag
    _enc = pow(enc_flag, config.e, n)

    with open ("flag.txt", "wb") as flag_file:
        flag_file.write(_enc.to_bytes(n.bit_length(), "little"))

    # Export RSA Key
    rsa = RSA.construct((n, config.e))
    with open ("public.pem", "w") as pub_file:
        pub_file.write(rsa.exportKey().decode())
```

á»ž Ä‘Ã¢y thÃ¬ mÃ¬nh cÃ³ thá»ƒ tháº¥y Ä‘Æ°á»£c class liÃªn quan tá»›i LCG cá»§a chÃºng ta. KhÃ¡c má»™t chÃºt so vá»›i mÃ¬nh vá»«a phÃ¢n tÃ­ch, nÃ³ sá»­ dá»¥ng m cho multiplier, c cho increment, vÃ  n cho modulus

Äá»c qua Ä‘oáº¡n code dung LCG thÃ¬ mÃ¬nh nháº­n ra nÃ³ hoáº¡t Ä‘á»™ng nhÆ° sau:

- DÃ¹ng thuáº­t toÃ¡n LCG Ä‘á»ƒ gen ra hÃ ng loáº¡t cÃ¡c sá»‘ ngáº«u nhiÃªn
- Dump 6 káº¿t quáº£ Ä‘áº§u tiÃªn vÃ o file **dump.txt**
- Táº¡o ra 1 array chá»©a 8 sá»‘ nguyÃªn tá»‘ 512 bits (*primes\_arr*)

Viá»‡c cÃ²n láº¡i lÃ  dÃ¹ng káº¿t quáº£ thu Ä‘Æ°á»£c Ä‘á»ƒ táº¡o nÃªn má»™t challenge vá» RSA:

- Táº¡o ra public key n báº±ng cÃ¡ch nhÃ¢n cÃ¡c sá»‘ nguyÃªn tá»‘ thu Ä‘Æ°á»£c á»Ÿ trÃªn vá»›i nhau
- Táº¡o ra totient Phin báº±ng cÃ¡ch nhÃ¢n hiá»‡u vá»›i 1 cá»§a cÃ¡c sá»‘ nguyÃªn tá»‘ trÃªn vá»›i nhau
- Táº¡o ra private key d vá»›i e trong *config*
- Láº¥y flag ra tá»« *config* vÃ  encrypt nÃ³, viáº¿t vÃ o file **flag.txt** dÆ°á»›i dáº¡ng bytes theo little-endian
- Export rsa key vÃ o file **public.pem**
- Viá»‡c chÃºng ta cáº§n lÃ m á»Ÿ Ä‘Ã¢y lÃ  giáº£i mÃ£ Ä‘Æ°á»£c flag, hay chÃºng ta cáº§n tÃ­nh Ä‘Æ°á»£c private key d.

Problem solving:

Do rsa public key Ä‘Ã£ Ä‘Æ°á»£c export vÃ o file **public.pem** nÃªn mÃ¬nh cÃ³ thá»ƒ láº¥y Ä‘Æ°á»£c n vÃ  e tá»« Ä‘Ã³.

Ban Ä‘áº§u, mÃ¬nh dÃ¹ng 6 sá»‘ Ä‘Æ°á»£c dump á»Ÿ trong file **dump.txt** Ä‘á»ƒ tÃ­nh d (ÄÆ°Æ¡ng nhiÃªn lÃ  sai bÃ©t rá»“i :v). Ngá»“i nghÄ© láº¡i thÃ¬ mÃ¬nh nghÄ© liá»‡u cÃ³ thá»ƒ tÃ­nh ngÆ°á»£c láº¡i cÃ¡c tham sá»‘ m, a, c á»Ÿ trong LCG dá»±a trÃªn 6 sá»‘ Ä‘Ã³ khÃ´ng. 

NhÆ° á»Ÿ trÃªn thÃ¬ mÃ¬nh Ä‘Ã£ biáº¿t ráº±ng:

Xn+1= (aXn+ c) mod m

ÄÃ¢y chá»‰ Ä‘Æ¡n giáº£n lÃ  má»™t phÆ°Æ¡ng trÃ¬nh cÃ³ 3 áº©n. Vá»›i 6 sá»‘ Ä‘Æ°á»£c gen ra tá»« nÃ³, mÃ¬nh nghÄ© mÃ¬nh hoÃ n toÃ n cÃ³ thá»ƒ tÃ­nh Ä‘Æ°á»£c chÃºng. MÃ¬nh cÃ³:

X1= (aX0+ c) mod m

X2= (aX1+ c) mod m

X3= (aX2+ c) mod m

Ba phÆ°Æ¡ng trÃ¬nh trÃªn tÆ°Æ¡ng Ä‘Æ°Æ¡ng vá»›i:

aX0+c=k1m+X1

aX1+c=k2m+X2

aX2+c=k3m+X3

Tuy nhiÃªn, giá» thÃ¬ mÃ¬nh láº¡i cÃ³ táº­n 6 áº©n nhÆ°ng chá»‰ cÃ³ 3 phÆ°Æ¡ng trÃ¬nh. Má»i chuyá»‡n cÃ³ váº» Ä‘i vÃ o báº¿ táº¯c cho Ä‘áº¿n khi mÃ¬nh tÃ¬m Ä‘Æ°á»£c trang nÃ y:

<https://tailcall.net/posts/cracking-rngs-lcgs/>

á»ž Ä‘Ã¢y, há» Ä‘Ã£ cÃ³ sáºµn code Ä‘á»ƒ cÃ³ thá»ƒ láº¥y Ä‘Æ°á»£c m, a, c tá»« cÃ¡c sá»‘ Ä‘Æ°á»£c sinh ra bá»Ÿi LCG. MÃ¬nh Ä‘Ã£ Ä‘á»c vÃ  chÆ°a thá»±c sá»± hiá»ƒu sÃ¢u vá» pháº§n phÃ¢n tÃ­ch tiáº¿p theo nÃªn mÃ¬nh sáº½ nghiÃªn cá»©u vÃ  ghi láº¡i sau. Giá» thÃ¬ cá»© dÃ¹ng sá»‘ code mÃ  ngÆ°á»i viáº¿t Ä‘Ã£ cung cáº¥p Ä‘á»ƒ giáº£i Ä‘Ã£. MÃ¬nh viáº¿t má»™t file **lcg.py** Ä‘á»ƒ tÃ¬m ra 3 tham sá»‘ Ä‘Ã³:

```python
import math
import functools

reduce = functools.reduce
gcd = math.gcd

X = [
    2166771675595184069339107365908377157701164485820981409993925279512199123418374034275465590004848135946671454084220731645099286746251308323653144363063385,
    6729272950467625456298454678219613090467254824679318993052294587570153424935267364971827277137521929202783621553421958533761123653824135472378133765236115,
    2230396903302352921484704122705539403201050490164649102182798059926343096511158288867301614648471516723052092761312105117735046752506523136197227936190287,
    4578847787736143756850823407168519112175260092601476810539830792656568747136604250146858111418705054138266193348169239751046779010474924367072989895377792,
    7578332979479086546637469036948482551151240099803812235949997147892871097982293017256475189504447955147399405791875395450814297264039908361472603256921612,
    2550420443270381003007873520763042837493244197616666667768397146110589301602119884836605418664463550865399026934848289084292975494312467018767881691302197
]

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, x, y = egcd(b % a, a)
        return (g, y - (b // a) * x, x)

def modinv(b, n):
    g, x, _ = egcd(b, n)
    if g == 1:
        return x % n

def crack_unknown_increment(states, modulus, multiplier):
    increment = (states[1] - states[0]*multiplier) % modulus
    return modulus, multiplier, increment

def crack_unknown_multiplier(states, modulus):
    multiplier = (states[2] - states[1]) * modinv(states[1] - states[0], modulus) % modulus
    return crack_unknown_increment(states, modulus, multiplier)

def crack_unknown_modulus(states):
    diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])]
    zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])]
    modulus = abs(reduce(gcd, zeroes))
    return crack_unknown_multiplier(states, modulus)


lcg = crack_unknown_modulus([
    2166771675595184069339107365908377157701164485820981409993925279512199123418374034275465590004848135946671454084220731645099286746251308323653144363063385,
    6729272950467625456298454678219613090467254824679318993052294587570153424935267364971827277137521929202783621553421958533761123653824135472378133765236115,
    2230396903302352921484704122705539403201050490164649102182798059926343096511158288867301614648471516723052092761312105117735046752506523136197227936190287,
    4578847787736143756850823407168519112175260092601476810539830792656568747136604250146858111418705054138266193348169239751046779010474924367072989895377792,
    7578332979479086546637469036948482551151240099803812235949997147892871097982293017256475189504447955147399405791875395450814297264039908361472603256921612,
    2550420443270381003007873520763042837493244197616666667768397146110589301602119884836605418664463550865399026934848289084292975494312467018767881691302197
])

print(lcg)

```
![image](https://github.com/AcceleratorHTH/CEA201/assets/86862725/ca2c1d90-7dd3-465c-bfe8-e87941731f52)

VÃ  tháº­t tuyá»‡t lÃ  nÃ³ Ä‘Ã£ hoáº¡t Ä‘á»™ng. Giá» Ä‘Ã¢y khi Ä‘Ã£ cÃ³ Ä‘á»§ nhá»¯ng tham sá»‘ cá»§a thuáº­t toÃ¡n LCG sá»­ dá»¥ng trong challenge, mÃ¬nh chá»‰ cáº§n sá»­a code cá»§a **generate.py** Ä‘i má»™t chÃºt lÃ  cÃ³ thá»ƒ ra Ä‘Æ°á»£c káº¿t quáº£. ÄÃ¢y lÃ  code Ä‘á»ƒ giáº£i challenge nÃ y cá»§a mÃ¬nh:

```python
from Crypto.Util.number import inverse, long_to_bytes, bytes_to_long, isPrime
from Crypto.PublicKey import RSA

# Read the public key from the file
with open('public.pem', 'r') as f:
    key = RSA.importKey(f.read())

e = key.e
n = key.n

class LCG:
    # the "multiplier"
    lcg_m = 99470802153294399618017402366955844921383026244330401927153381788409087864090915476376417542092444282980114205684938728578475547514901286372129860608477 
     # the "increment"
    lcg_c = 3910539794193409979886870049869456815685040868312878537393070815966881265118275755165613835833103526090552456472867019296386475520134783987251699999776365
    # the "modulus"
    lcg_n = 8311271273016946265169120092240227882013893131681882078655426814178920681968884651437107918874328518499850252591810409558783335118823692585959490215446923

    def __init__(self, lcg_s):
        self.state = lcg_s

    def next(self):
        self.state = (self.state * self.lcg_m + self.lcg_c) % self.lcg_n
        return self.state

if __name__ == '__main__':

    # Find prime value of specified bits a specified amount of times
    seed = 211286818345627549183608678726370412218029639873054513839005340650674982169404937862395980568550063504804783328450267566224937880641772833325018028629959635
    lcg = LCG(seed)
    primes_arr = []
    
    items = 0

    primes_n = 1
    while True:
        for i in range(8):
            while True:
                prime_candidate = lcg.next()
                if not isPrime(prime_candidate):
                    continue
                elif prime_candidate.bit_length() != 512:
                    continue
                else:
                    primes_n *= prime_candidate
                    primes_arr.append(prime_candidate)
                    break
        
        # Check bit length
        if primes_n.bit_length() > 4096:
            print("bit length", primes_n.bit_length())
            primes_arr.clear()
            primes_n = 1
            continue
        else:
            break

    # Calculate totient 'Phi(n)'
    phi = 1
    for k in primes_arr:
        phi *= (k - 1)

    # Calculate private key 'd'
    d = inverse(e, phi)

    # Read the encrypted flag
    with open('flag.txt', 'rb') as f:
        enc_flag = int.from_bytes(f.read(), 'little')

    flag = pow(enc_flag, d, n)
    print(long_to_bytes(flag))

```

VÃ  khi cháº¡y code, ta sáº½ nháº­n Ä‘Æ°á»£c káº¿t quáº£:
![image](https://github.com/AcceleratorHTH/CEA201/assets/86862725/8785cabe-ab36-46ef-b242-ea85afc68d5d)

Flag: CTF{C0nGr@tz\_RiV35t\_5h4MiR\_nD\_Ad13MaN\_W0ulD\_b\_h@pPy}

**Â© 2023,Pham Quoc Trung. All rights reserved.**



















