---
title: Groebner Basis
description: CTF-Crypto
author: Pr0pylTh10ur4C1L
date: 2024-06-12 12:04:00 +0700
categories: [Mathematic]
tags: []
pin: true
math: true
mermaid: true
published: false
---

# Groebner Basis

## Định nghĩa
**Groebner basis** là một tập hợp các đa thức có những tính chất đặc biệt giúp giải quyết các vấn đề về hệ phương trình đa thức và lý thuyết các vành đa thức. Nó được đặt theo tên nhà toán học người Áo Wolfgang Gröbner. Groebner basis có nhiều ứng dụng trong đại số giao hoán, hình học đại số, và lý thuyết điều khiển.

Các Đặc Điểm Chính của **Groebner Basis**   
- Tính Đồng dạng: Mọi ideal (một tập hợp các đa thức đóng dưới phép cộng và nhân với một đa thức bất kỳ) trong một vành đa thức đều có thể được biểu diễn bằng một Groebner basis.
- Độc Nhất: Với một ideal và một thứ tự đơn biến (monomial order) cho trước, Groebner basis là duy nhất.
- Giải Hệ Phương Trình: Groebner basis cho phép giải hệ phương trình đa thức bằng cách biến đổi chúng thành một dạng đơn giản hơn (thường giống như dạng bậc thang trong ma trận).
- Ứng dụng: Groebner basis được sử dụng để kiểm tra tính nhất quán của hệ phương trình, tìm nghiệm của hệ phương trình, và thực hiện các phép tính trong lý thuyết các vành đa thức và hình học đại số.

> Đơn giản là nó sẽ cho chúng ta một hệ đa thức/đa thức mới đơn giản hơn, thường là sẽ chỉ là những đa thức một biến (có thể giải luôn)

## Áp dụng vào CTF
Ở đây mình sử dụng một challenge trong giải KCSC

```python
import random
from Crypto.Util.number import *

NBITS = 2048

def pad(msg, nbits):
    """msg -> trash | 0x00 | msg"""
    pad_length = nbits - len(msg) * 8 - 8
   
    assert pad_length >= 0
    pad = random.getrandbits(pad_length).to_bytes((pad_length+7) // 8, "big")
    return pad + b"\x00" + msg


if __name__ == '__main__':
    p = getPrime(NBITS//2)
    q = getPrime(NBITS//2)
    n = p*q
    e = 3
    print('n =',n)
    flag = b'KCSC{s0m3_r3ad4ble_5tr1ng_like_7his}'
    flag1 = int.from_bytes(pad(flag[:len(flag)//2], NBITS-1), "big")
    flag2 = int.from_bytes(pad(flag[len(flag)//2:], NBITS-1), "big")
    print('c1 =', pow(flag1, e, n))
    print('c2 =', pow(flag2, e, n))
    print('c3 =', pow(flag1 + flag2 + 2024, e, n))
    
    
#n = 20309506650796881616529290664036466538489386425747108847329314416833872927305399144955238770343216928093685748677981345624111315501596571108286475815937548732237777944966756121878930547704154830118623697713050651175872498696886388591990290649008566165706882183536432074074093989165129982027471595363186012032012716786766898967178702932387828604019583820419525077836905310644900660107030935400863436580408288191459013552406498847690908648207805504191001496170310089546275003489343333654260825796730484675948772646479183783762309135891162431343426271855443311093315537542013161936068129247159333498199039105461683433559
#c1 = 4199114785395079527708590502284487952499260901806619182047635882351235136067066118088238258758190817298694050837954512048540738666568371021705303034447643372079128117357999230662297600296143681452520944664127802819585723070008246552551484638691165362269408201085933941408723024036595945680925114050652110889316381605080307039620210609769392683351575676103028568766527469370715488668422245141709925930432410059952738674832588223109550486203200795541531631718435391186500053512941594901330786938768706895275374971646539833090714455557224571309211063383843267282547373014559640119269509932424300539909699047417886111314
#2 = 15650490923019220133875152059331365766693239517506051173267598885807661657182838682038088755247179213968582991397981250801642560325035309774037501160195325905859961337459025909689911567332523970782429751122939747242844779503873324022826268274173388947508160966345513047092282464148309981988907583482129247720207815093850363800732109933366825533141246927329087602528196453603292618745790632581329788674987853984153555891779927769670258476202605061744673053413682672209298008811597719866629672869500235237620887158099637238077835474668017416820127072548341550712637174520271022708396652014740738238378199870687994311904
#c3 = 18049611726836505821453817372562316794589656109517250054347456683556431747564647553880528986894363034117226538032533356275073007558690442144224643000621847811625558231542435955117636426010023056741993285381967997664265021610409564351046101786654952679193571324445192716616759002730952101112316495837569266130959699342032640740375761374993415050076510886515944123594545916167183939520495851349542048972495703489407916038504032996901940696359461636008398991990191156647394833667609213829253486672716593224216112049920602489681252392770813768169755622341704890099918147629758209742872521177691286126574993863763318087398
```

Ở đây ta có 3 phương trình như sau

$$ x^3 \equiv c1 \pmod{n} $$  
$$ y^3 \equiv c_2 \pmod{n} $$  
$$ (x + y + 2024)^3 \equiv c3 \pmod{n} $$  

Ta sẽ sử dụng **groebner_basis** để lấy ra các đa thức mới. Đây là cách làm trong sagemath:

Đầu tiên, ta sẽ khai báo các đa thức
```python
n = 20309506650796881616529290664036466538489386425747108847329314416833872927305399144955238770343216928093685748677981345624111315501596571108286475815937548732237777944966756121878930547704154830118623697713050651175872498696886388591990290649008566165706882183536432074074093989165129982027471595363186012032012716786766898967178702932387828604019583820419525077836905310644900660107030935400863436580408288191459013552406498847690908648207805504191001496170310089546275003489343333654260825796730484675948772646479183783762309135891162431343426271855443311093315537542013161936068129247159333498199039105461683433559
c1 = 4199114785395079527708590502284487952499260901806619182047635882351235136067066118088238258758190817298694050837954512048540738666568371021705303034447643372079128117357999230662297600296143681452520944664127802819585723070008246552551484638691165362269408201085933941408723024036595945680925114050652110889316381605080307039620210609769392683351575676103028568766527469370715488668422245141709925930432410059952738674832588223109550486203200795541531631718435391186500053512941594901330786938768706895275374971646539833090714455557224571309211063383843267282547373014559640119269509932424300539909699047417886111314
c2 = 15650490923019220133875152059331365766693239517506051173267598885807661657182838682038088755247179213968582991397981250801642560325035309774037501160195325905859961337459025909689911567332523970782429751122939747242844779503873324022826268274173388947508160966345513047092282464148309981988907583482129247720207815093850363800732109933366825533141246927329087602528196453603292618745790632581329788674987853984153555891779927769670258476202605061744673053413682672209298008811597719866629672869500235237620887158099637238077835474668017416820127072548341550712637174520271022708396652014740738238378199870687994311904
c3 = 18049611726836505821453817372562316794589656109517250054347456683556431747564647553880528986894363034117226538032533356275073007558690442144224643000621847811625558231542435955117636426010023056741993285381967997664265021610409564351046101786654952679193571324445192716616759002730952101112316495837569266130959699342032640740375761374993415050076510886515944123594545916167183939520495851349542048972495703489407916038504032996901940696359461636008398991990191156647394833667609213829253486672716593224216112049920602489681252392770813768169755622341704890099918147629758209742872521177691286126574993863763318087398
P.<x,y> = PolynomialRing(Zmod(n))
f1 = (x)^3 - c1
f2 = (y)^3 - c2
f3 = (x+y+2024)^3 - c3
```

Sử dụng `ideal` để dựng một hệ phương trình bao gồm 3 phương trình trên trong trường hữu hạn Zmod(n)
> Sẽ giải thích thêm về ideal, nhưng có thể dùng như 1 cách tạo HPT cho dễ (sai bản chất)

```python
I = P.ideal(f1,f2,f3)
I
# Ideal (x^3 + 16110391865401802088820700161751978585990125523940489665281678534482637791238333026867000511585026110794991697840026833575570576835028200086581172781489905360158649827608756891216632947408011148666102753048922848356286775626878142039438806010317400803437473982450498132665370965128534036346546481312533901142696335181686591927558492322618435920668008144316496509070377841274185171438608690259153510649975878131506274877573910624581358162004604708649469864451874698359774949976401738752930038857961777780673397674832643950671594680333937860034215208471600043810768164527453521816798619314735032958289340058043797322245, y^3 + 4659015727777661482654138604705100771796146908241057674061715531026211270122560462917150015096037714125102757280000094822468755176561261334248974655742222826377816607507730212189018980371630859336193946590110903933027719193013064569164022374835177218198721217190919026981811525016820000038564011881056764311804901692916535166446592999021003070878336893090437475308708857041608041361240302819533647905420434207305457660626571078020650172005200442446328442756627417336976994677745613787631152927230249438327885488379546545684473661223145014523299199307101760380678363021742139227671477232418595259820839234773689121655, x^3 + 3*x^2*y + 3*x*y^2 + y^3 + 6072*x^2 + 12144*x*y + 6072*y^2 + 12289728*x + 12289728*y + 2259894923960375795075473291474149743899730316229858792981857733277441179740751591074709783448853893976459210645447989349038307942906128964061832815315700920612219713424320166761294121694131773376630412331082653511607477086476824240944188862353613486513310859091239357457334986434177880915155099525616745901053017444734258226802941557394413553943072933903580954242359394477716720586535084051321387607912584702051097513902465850788967951848343868182602504180118932898880169821734119825007339124013891451732660596558581294081056743120348663173670649513738420993397389912254952193195608069468047371624045241706656815985) of Multivariate Polynomial Ring in x, y over Ring of integers modulo 20309506650796881616529290664036466538489386425747108847329314416833872927305399144955238770343216928093685748677981345624111315501596571108286475815937548732237777944966756121878930547704154830118623697713050651175872498696886388591990290649008566165706882183536432074074093989165129982027471595363186012032012716786766898967178702932387828604019583820419525077836905310644900660107030935400863436580408288191459013552406498847690908648207805504191001496170310089546275003489343333654260825796730484675948772646479183783762309135891162431343426271855443311093315537542013161936068129247159333498199039105461683433559
```

Sử dụng `groebner_basis` để tạo ra các tập sinh đơn giản hơn

```python
I.groebner_basis()
# [x + 13735276216480234294706359844820346892092177215553901414391761850858882460635783205472406746662036273971992070607261796127119688947318559763272879567995396491115716121316753574975647148161690034108438505248524970885551589159652876676870846257287752279898736691564266993215011110767376345954955541741948634680315084968263393711859569144349753495551546569343780951427789448111710124904988309966385084377510291750050932987581798768855247780396174181337264410175133260701357189505301070362322065230989981704250274145256779438951189476596306356433095883900881070769915283761198556147219781991864498300605360624190735499303, y + 10850063064215786153306327148990924788438984598023598141431813572034023665508993022819406328531276035415236463762473907444014785919774345550388745382570351421234382216484857722363728432223575478904468786551137995573395304260701532033474455590992994546092536998679869622456414388329561594251029715255159436038660362296817381481412123357555319521172263012404519048712465622333028074769426400066439085668811357134225445548178218655872653355541146025686046192241356344100333096851330334054858073508194708777534526473121314794434611660370071725086052980875155623377312829194652529259245234592714291772331661063675437706202]
```

Ở đây thì ta thu được hai đa thức trên vành Zmod(n):

$$ 0 \equiv (x + x_0) \pmod{n} $$  
$$ 0 \equiv (y + y_0) \pmod{n} $$
