---
title: WaniCTF 2024
description: CTF-Crypto
author: Pr0pylTh10ur4C1L
date: 2024-06-24 10:37:00 +0700
categories: [Capture The Flag]
tags: [Cryptography]
math: true
mermaid: true
---

## beginners_rsa
### Description:
Do you know RSA?

### Attachments:
*chall.py*
```python
from Crypto.Util.number import *

p = getPrime(64)
q = getPrime(64)
r = getPrime(64)
s = getPrime(64)
a = getPrime(64)
n = p*q*r*s*a
e = 0x10001

FLAG = b'FLAG{This_is_a_fake_flag}'
m = bytes_to_long(FLAG)
enc = pow(m, e, n)
print(f'n = {n}')
print(f'e = {e}')
print(f'enc = {enc}')
```

*output.txt*
```
n = 317903423385943473062528814030345176720578295695512495346444822768171649361480819163749494400347
e = 65537
enc = 127075137729897107295787718796341877071536678034322988535029776806418266591167534816788125330265
```

### Analysis:
Bài này là một bài RSA cơ bản, chỉ khác là thay vì p,q thì ta có p, q, r, s, a. Mọi thao tác vẫn sẽ như bình thường chỉ khác là thêm các số r, s, a. Do các số này đều rất nhỏ (64-bit) nên mình sẽ dùng ECM_HTM để recover và lấy được flag

### Solution:
```python
from Crypto.Util.number import *

n = 317903423385943473062528814030345176720578295695512495346444822768171649361480819163749494400347
e = 65537
enc = 127075137729897107295787718796341877071536678034322988535029776806418266591167534816788125330265

# 317903 423385 943473 062528 814030 345176 720578 295695 512495 346444 822768 171649 361480 819163 749494 400347 (96 digits) = 9 953162 929836 910171 × 11 771834 931016 130837 × 12 109985 960354 612149 × 13 079524 394617 385153 × 17 129880 600534 041513 

p = 9953162929836910171
q = 11771834931016130837
r = 12109985960354612149
s = 13079524394617385153
a = 17129880600534041513

assert n == p*q*r*s*a

phi = (p-1)*(q-1)*(r-1)*(s-1)*(a-1)
d = inverse(e, phi)

print(long_to_bytes(pow(enc, d, n)))
```
Flag: *FLAG{S0_3a5y_1254!!}*

## beginners-aes
### Description:
AES is one of the most important encryption methods in our daily lives.

### Attachments:
*chall.py*
```python
# https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html
from Crypto.Util.Padding import pad
from Crypto.Cipher import AES
from os import urandom
import hashlib

key = b'the_enc_key_is_'
iv = b'my_great_iv_is_'
key += urandom(1)
iv += urandom(1)

cipher = AES.new(key, AES.MODE_CBC, iv)
FLAG = b'FLAG{This_is_a_dummy_flag}'
flag_hash = hashlib.sha256(FLAG).hexdigest()

msg = pad(FLAG, 16)
enc = cipher.encrypt(msg)

print(f'enc = {enc}') # bytes object
print(f'flag_hash = {flag_hash}') # str object
```

*output.txt*
```
enc = b'\x16\x97,\xa7\xfb_\xf3\x15.\x87jKRaF&"\xb6\xc4x\xf4.K\xd77j\xe5MLI_y\xd96\xf1$\xc5\xa3\x03\x990Q^\xc0\x17M2\x18'
flag_hash = 6a96111d69e015a07e96dcd141d31e7fc81c4420dbbef75aef5201809093210e
```

### Analysis:
Bài này cho ta ciphertext được mã hóa sử dụng AES_CBC và một hash SHA256 của flag. Do key và iv đã được cho sẵn, chỉ thiếu 1 bytes cuối là chưa biết, ta hoàn toàn có thể brute force và giải mã ra được flag.

Kết quả giải mã sẽ ra nhiều nên ta sẽ sử dụng hash SHA256 để check xem cái nào mới là flag.

### Solution:
```python
from Crypto.Util.Padding import unpad
from Crypto.Cipher import AES
import hashlib

enc = b'\x16\x97,\xa7\xfb_\xf3\x15.\x87jKRaF&"\xb6\xc4x\xf4.K\xd77j\xe5MLI_y\xd96\xf1$\xc5\xa3\x03\x990Q^\xc0\x17M2\x18'
checksum = "6a96111d69e015a07e96dcd141d31e7fc81c4420dbbef75aef5201809093210e"

for i in range(256):
    for j in range(256):
        key = b'the_enc_key_is_'
        iv = b'my_great_iv_is_'
        key += chr(i).encode()
        iv += chr(j).encode()

        try:
            cipher = AES.new(key, AES.MODE_CBC, iv)
            flag = cipher.decrypt(enc)
            if b"FLAG" in flag:
                flag_hash = hashlib.sha256(unpad(flag, 16)).hexdigest()
                if flag_hash == checksum:
                    print(unpad(flag, 16))
        except:
            continue
```
Flag: *FLAG{7h3_f1r57_5t3p_t0_Crypt0!!}*

## replacement
### Description:
No one can read my diary!

### Attachments:
*chall.py*
```python
from secret import cal
import hashlib

enc = []
for char in cal:
    x = ord(char)
    x = hashlib.md5(str(x).encode()).hexdigest()
    enc.append(int(x, 16))
        
with open('my_diary_11_8_Wednesday.txt', 'w') as f:
    f.write(str(enc))
```

*my_diary_11_8_Wednesday.txt*
```
[265685380796387128074260337556987156845, 75371056103973480373443517203033791314, 330443362254714811278522520670919771869, 127044987962124214100696270195559210814, 75371056103973480373443517203033791314, 57512852240092789512489991536185408584, 330443362254714811278522520670919771869, 301648155472379285594517050531127483548, 101473043316046160883738884593606957434, 328441037604453537976363247914938474182, 132117099947440863086225782187112663809, 324787361952219506718126426467652498112, 324787361952219506718126426467652498112, 137941842177346839522203666758205652951, 211852213467947252418279649849888928870, 328441037604453537976363247914938474182, 132117099947440863086225782187112663809, 229138548907862643092856609226723050075, 217694107356916866121607052237984398603, 75371056103973480373443517203033791314, 301648155472379285594517050531127483548, 127360297788558372456973998053019048669, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 225291938577970489582719213714180290820, 135217442928347349540220511812067137647, 75371056103973480373443517203033791314, 57512852240092789512489991536185408584, 289548202804218369273708443831392368399, 132117099947440863086225782187112663809, 139335500873816609567900312949843139873, 268343242210070543641525550351035429524, 135217442928347349540220511812067137647, 57512852240092789512489991536185408584, 132117099947440863086225782187112663809, 52025852590564328496031723616521325469, 140302709094137701773086334180578563688, 127360297788558372456973998053019048669, 127044987962124214100696270195559210814, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 328441037604453537976363247914938474182, 132117099947440863086225782187112663809, 280290124780175821729678400814355564485, 132117099947440863086225782187112663809, 268343242210070543641525550351035429524, 301648155472379285594517050531127483548, 330443362254714811278522520670919771869, 132117099947440863086225782187112663809, 315344660197335367320188253944546305738, 127360297788558372456973998053019048669, 75371056103973480373443517203033791314, 301648155472379285594517050531127483548, 225291938577970489582719213714180290820, 314410903843616126162868425563187236446, 301648155472379285594517050531127483548, 57512852240092789512489991536185408584, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 301648155472379285594517050531127483548, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 52025852590564328496031723616521325469, 101473043316046160883738884593606957434, 132117099947440863086225782187112663809, 314410903843616126162868425563187236446, 301648155472379285594517050531127483548, 126195399674046097926516865351960453821, 140302709094137701773086334180578563688, 127360297788558372456973998053019048669, 135217442928347349540220511812067137647, 260950720930659604756740365450507371663, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 229138548907862643092856609226723050075, 301648155472379285594517050531127483548, 314410903843616126162868425563187236446, 75371056103973480373443517203033791314, 289548202804218369273708443831392368399, 132117099947440863086225782187112663809, 217928829273870340501940171394986772443, 127360297788558372456973998053019048669, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 225291938577970489582719213714180290820, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 314410903843616126162868425563187236446, 127360297788558372456973998053019048669, 75371056103973480373443517203033791314, 57512852240092789512489991536185408584, 268343242210070543641525550351035429524, 217694107356916866121607052237984398603, 101473043316046160883738884593606957434, 132117099947440863086225782187112663809, 315344660197335367320188253944546305738, 127360297788558372456973998053019048669, 75371056103973480373443517203033791314, 10477030623836167233684437098032507967, 75371056103973480373443517203033791314, 330443362254714811278522520670919771869, 132117099947440863086225782187112663809, 229138548907862643092856609226723050075, 140302709094137701773086334180578563688, 314410903843616126162868425563187236446, 314410903843616126162868425563187236446, 75371056103973480373443517203033791314, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 301648155472379285594517050531127483548, 127044987962124214100696270195559210814, 330443362254714811278522520670919771869, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 301648155472379285594517050531127483548, 126195399674046097926516865351960453821, 140302709094137701773086334180578563688, 127360297788558372456973998053019048669, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 10477030623836167233684437098032507967, 301648155472379285594517050531127483548, 127360297788558372456973998053019048669, 52025852590564328496031723616521325469, 132117099947440863086225782187112663809, 315344660197335367320188253944546305738, 312483091106876729395161500591121481064, 260950720930659604756740365450507371663, 260950720930659604756740365450507371663, 75371056103973480373443517203033791314, 127360297788558372456973998053019048669, 101473043316046160883738884593606957434, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 140302709094137701773086334180578563688, 301648155472379285594517050531127483548, 57512852240092789512489991536185408584, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 135217442928347349540220511812067137647, 57512852240092789512489991536185408584, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 315344660197335367320188253944546305738, 75371056103973480373443517203033791314, 57512852240092789512489991536185408584, 260950720930659604756740365450507371663, 289548202804218369273708443831392368399, 132117099947440863086225782187112663809, 153336653484216014488860143974073426008, 268343242210070543641525550351035429524, 301648155472379285594517050531127483548, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 312483091106876729395161500591121481064, 315344660197335367320188253944546305738, 319779899260524384061247969332041066255, 75371056103973480373443517203033791314, 229138548907862643092856609226723050075, 260950720930659604756740365450507371663, 328441037604453537976363247914938474182, 132117099947440863086225782187112663809, 280290124780175821729678400814355564485, 132117099947440863086225782187112663809, 127360297788558372456973998053019048669, 75371056103973480373443517203033791314, 229138548907862643092856609226723050075, 75371056103973480373443517203033791314, 135217442928347349540220511812067137647, 126195399674046097926516865351960453821, 75371056103973480373443517203033791314, 330443362254714811278522520670919771869, 132117099947440863086225782187112663809, 301648155472379285594517050531127483548, 127044987962124214100696270195559210814, 132117099947440863086225782187112663809, 75371056103973480373443517203033791314, 52025852590564328496031723616521325469, 301648155472379285594517050531127483548, 135217442928347349540220511812067137647, 217694107356916866121607052237984398603, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 140302709094137701773086334180578563688, 330443362254714811278522520670919771869, 301648155472379285594517050531127483548, 101473043316046160883738884593606957434, 132117099947440863086225782187112663809, 10477030623836167233684437098032507967, 135217442928347349540220511812067137647, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 140302709094137701773086334180578563688, 52025852590564328496031723616521325469, 75371056103973480373443517203033791314, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 132117099947440863086225782187112663809, 127360297788558372456973998053019048669, 301648155472379285594517050531127483548, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 75371056103973480373443517203033791314, 127360297788558372456973998053019048669, 132117099947440863086225782187112663809, 169393384228144871625990433807197966773, 75371056103973480373443517203033791314, 229138548907862643092856609226723050075, 312483091106876729395161500591121481064, 217694107356916866121607052237984398603, 135217442928347349540220511812067137647, 301648155472379285594517050531127483548, 127360297788558372456973998053019048669, 132117099947440863086225782187112663809, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 132117099947440863086225782187112663809, 135217442928347349540220511812067137647, 260950720930659604756740365450507371663, 289548202804218369273708443831392368399, 132117099947440863086225782187112663809, 280290124780175821729678400814355564485, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 229138548907862643092856609226723050075, 140302709094137701773086334180578563688, 127044987962124214100696270195559210814, 260950720930659604756740365450507371663, 301648155472379285594517050531127483548, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 75371056103973480373443517203033791314, 330443362254714811278522520670919771869, 132117099947440863086225782187112663809, 301648155472379285594517050531127483548, 132117099947440863086225782187112663809, 52025852590564328496031723616521325469, 101473043316046160883738884593606957434, 57512852240092789512489991536185408584, 260950720930659604756740365450507371663, 75371056103973480373443517203033791314, 127360297788558372456973998053019048669, 135217442928347349540220511812067137647, 140302709094137701773086334180578563688, 312483091106876729395161500591121481064, 57512852240092789512489991536185408584, 132117099947440863086225782187112663809, 52025852590564328496031723616521325469, 75371056103973480373443517203033791314, 57512852240092789512489991536185408584, 57512852240092789512489991536185408584, 301648155472379285594517050531127483548, 140175431361313732288440547599619953992, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 301648155472379285594517050531127483548, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 301648155472379285594517050531127483548, 135217442928347349540220511812067137647, 330443362254714811278522520670919771869, 132117099947440863086225782187112663809, 302282648683284548814202807340787655613, 139335500873816609567900312949843139873, 268343242210070543641525550351035429524, 135217442928347349540220511812067137647, 57512852240092789512489991536185408584, 132117099947440863086225782187112663809, 135217442928347349540220511812067137647, 57512852240092789512489991536185408584, 132117099947440863086225782187112663809, 301648155472379285594517050531127483548, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 75371056103973480373443517203033791314, 229138548907862643092856609226723050075, 127360297788558372456973998053019048669, 75371056103973480373443517203033791314, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 229138548907862643092856609226723050075, 140302709094137701773086334180578563688, 330443362254714811278522520670919771869, 75371056103973480373443517203033791314, 328441037604453537976363247914938474182, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 140302709094137701773086334180578563688, 132117099947440863086225782187112663809, 169393384228144871625990433807197966773, 217694107356916866121607052237984398603, 75371056103973480373443517203033791314, 301648155472379285594517050531127483548, 57512852240092789512489991536185408584, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 330443362254714811278522520670919771869, 140302709094137701773086334180578563688, 127044987962124214100696270195559210814, 285106641514631128245889883706054218556, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 75371056103973480373443517203033791314, 217694107356916866121607052237984398603, 217694107356916866121607052237984398603, 132117099947440863086225782187112663809, 301648155472379285594517050531127483548, 127044987962124214100696270195559210814, 101473043316046160883738884593606957434, 140302709094137701773086334180578563688, 127044987962124214100696270195559210814, 75371056103973480373443517203033791314, 289548202804218369273708443831392368399, 132117099947440863086225782187112663809, 165799207128434858641672726827070059029, 334755564751598048042394781213255939012, 335344749019279195985775024993445213947, 301423883473918993177634428163190101268, 42767516990368493138776584305024125808, 324787361952219506718126426467652498112, 53459933652527578064242465506376923016, 75371056103973480373443517203033791314, 169393384228144871625990433807197966773, 217694107356916866121607052237984398603, 204791166937441563272975036703176244680, 229138548907862643092856609226723050075, 75371056103973480373443517203033791314, 52025852590564328496031723616521325469, 53459933652527578064242465506376923016, 127044987962124214100696270195559210814, 260950720930659604756740365450507371663, 82324359399928500054185503234815398877, 302282648683284548814202807340787655613, 289548202804218369273708443831392368399, 132117099947440863086225782187112663809, 67435298396569627229809714987765527069, 140302709094137701773086334180578563688, 10477030623836167233684437098032507967, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 260950720930659604756740365450507371663, 127360297788558372456973998053019048669, 301648155472379285594517050531127483548, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 75371056103973480373443517203033791314, 32129299595146848534093479265394572654, 281595222973318803755638905082365601824, 281595222973318803755638905082365601824, 301423883473918993177634428163190101268, 312483091106876729395161500591121481064, 127360297788558372456973998053019048669, 75371056103973480373443517203033791314, 135217442928347349540220511812067137647, 57512852240092789512489991536185408584, 101473043316046160883738884593606957434, 301648155472379285594517050531127483548]
```

### Analysis:
Ở bài này, với mỗi kí tự trong flag sẽ được hash MD5, sau đó trả về mảng chứa các kí tự đã hash.

Mình sẽ lấy ra một list MD5 các kí tự trong bảng ASCII, sau đó sẽ so sánh với từng kí tự trong mảng bài cho. Nếu trùng hash thì sẽ là kí tự tương ứng trong bảng ASCII.

### Solution:
```python
import hashlib

md5_chrs = []
for i in range(256):
    hash_chr = hashlib.md5(str(i).encode()).hexdigest()
    md5_chrs.append(int(hash_chr, 16))

enc = [265685380796387128074260337556987156845, 75371056103973480373443517203033791314, 330443362254714811278522520670919771869, 127044987962124214100696270195559210814, 75371056103973480373443517203033791314, 57512852240092789512489991536185408584, 330443362254714811278522520670919771869, 301648155472379285594517050531127483548, 101473043316046160883738884593606957434, 328441037604453537976363247914938474182, 132117099947440863086225782187112663809, 324787361952219506718126426467652498112, 324787361952219506718126426467652498112, 137941842177346839522203666758205652951, 211852213467947252418279649849888928870, 328441037604453537976363247914938474182, 132117099947440863086225782187112663809, 229138548907862643092856609226723050075, 217694107356916866121607052237984398603, 75371056103973480373443517203033791314, 301648155472379285594517050531127483548, 127360297788558372456973998053019048669, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 225291938577970489582719213714180290820, 135217442928347349540220511812067137647, 75371056103973480373443517203033791314, 57512852240092789512489991536185408584, 289548202804218369273708443831392368399, 132117099947440863086225782187112663809, 139335500873816609567900312949843139873, 268343242210070543641525550351035429524, 135217442928347349540220511812067137647, 57512852240092789512489991536185408584, 132117099947440863086225782187112663809, 52025852590564328496031723616521325469, 140302709094137701773086334180578563688, 127360297788558372456973998053019048669, 127044987962124214100696270195559210814, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 328441037604453537976363247914938474182, 132117099947440863086225782187112663809, 280290124780175821729678400814355564485, 132117099947440863086225782187112663809, 268343242210070543641525550351035429524, 301648155472379285594517050531127483548, 330443362254714811278522520670919771869, 132117099947440863086225782187112663809, 315344660197335367320188253944546305738, 127360297788558372456973998053019048669, 75371056103973480373443517203033791314, 301648155472379285594517050531127483548, 225291938577970489582719213714180290820, 314410903843616126162868425563187236446, 301648155472379285594517050531127483548, 57512852240092789512489991536185408584, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 301648155472379285594517050531127483548, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 52025852590564328496031723616521325469, 101473043316046160883738884593606957434, 132117099947440863086225782187112663809, 314410903843616126162868425563187236446, 301648155472379285594517050531127483548, 126195399674046097926516865351960453821, 140302709094137701773086334180578563688, 127360297788558372456973998053019048669, 135217442928347349540220511812067137647, 260950720930659604756740365450507371663, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 229138548907862643092856609226723050075, 301648155472379285594517050531127483548, 314410903843616126162868425563187236446, 75371056103973480373443517203033791314, 289548202804218369273708443831392368399, 132117099947440863086225782187112663809, 217928829273870340501940171394986772443, 127360297788558372456973998053019048669, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 225291938577970489582719213714180290820, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 314410903843616126162868425563187236446, 127360297788558372456973998053019048669, 75371056103973480373443517203033791314, 57512852240092789512489991536185408584, 268343242210070543641525550351035429524, 217694107356916866121607052237984398603, 101473043316046160883738884593606957434, 132117099947440863086225782187112663809, 315344660197335367320188253944546305738, 127360297788558372456973998053019048669, 75371056103973480373443517203033791314, 10477030623836167233684437098032507967, 75371056103973480373443517203033791314, 330443362254714811278522520670919771869, 132117099947440863086225782187112663809, 229138548907862643092856609226723050075, 140302709094137701773086334180578563688, 314410903843616126162868425563187236446, 314410903843616126162868425563187236446, 75371056103973480373443517203033791314, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 301648155472379285594517050531127483548, 127044987962124214100696270195559210814, 330443362254714811278522520670919771869, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 301648155472379285594517050531127483548, 126195399674046097926516865351960453821, 140302709094137701773086334180578563688, 127360297788558372456973998053019048669, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 10477030623836167233684437098032507967, 301648155472379285594517050531127483548, 127360297788558372456973998053019048669, 52025852590564328496031723616521325469, 132117099947440863086225782187112663809, 315344660197335367320188253944546305738, 312483091106876729395161500591121481064, 260950720930659604756740365450507371663, 260950720930659604756740365450507371663, 75371056103973480373443517203033791314, 127360297788558372456973998053019048669, 101473043316046160883738884593606957434, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 140302709094137701773086334180578563688, 301648155472379285594517050531127483548, 57512852240092789512489991536185408584, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 135217442928347349540220511812067137647, 57512852240092789512489991536185408584, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 315344660197335367320188253944546305738, 75371056103973480373443517203033791314, 57512852240092789512489991536185408584, 260950720930659604756740365450507371663, 289548202804218369273708443831392368399, 132117099947440863086225782187112663809, 153336653484216014488860143974073426008, 268343242210070543641525550351035429524, 301648155472379285594517050531127483548, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 312483091106876729395161500591121481064, 315344660197335367320188253944546305738, 319779899260524384061247969332041066255, 75371056103973480373443517203033791314, 229138548907862643092856609226723050075, 260950720930659604756740365450507371663, 328441037604453537976363247914938474182, 132117099947440863086225782187112663809, 280290124780175821729678400814355564485, 132117099947440863086225782187112663809, 127360297788558372456973998053019048669, 75371056103973480373443517203033791314, 229138548907862643092856609226723050075, 75371056103973480373443517203033791314, 135217442928347349540220511812067137647, 126195399674046097926516865351960453821, 75371056103973480373443517203033791314, 330443362254714811278522520670919771869, 132117099947440863086225782187112663809, 301648155472379285594517050531127483548, 127044987962124214100696270195559210814, 132117099947440863086225782187112663809, 75371056103973480373443517203033791314, 52025852590564328496031723616521325469, 301648155472379285594517050531127483548, 135217442928347349540220511812067137647, 217694107356916866121607052237984398603, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 140302709094137701773086334180578563688, 330443362254714811278522520670919771869, 301648155472379285594517050531127483548, 101473043316046160883738884593606957434, 132117099947440863086225782187112663809, 10477030623836167233684437098032507967, 135217442928347349540220511812067137647, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 140302709094137701773086334180578563688, 52025852590564328496031723616521325469, 75371056103973480373443517203033791314, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 132117099947440863086225782187112663809, 127360297788558372456973998053019048669, 301648155472379285594517050531127483548, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 75371056103973480373443517203033791314, 127360297788558372456973998053019048669, 132117099947440863086225782187112663809, 169393384228144871625990433807197966773, 75371056103973480373443517203033791314, 229138548907862643092856609226723050075, 312483091106876729395161500591121481064, 217694107356916866121607052237984398603, 135217442928347349540220511812067137647, 301648155472379285594517050531127483548, 127360297788558372456973998053019048669, 132117099947440863086225782187112663809, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 132117099947440863086225782187112663809, 135217442928347349540220511812067137647, 260950720930659604756740365450507371663, 289548202804218369273708443831392368399, 132117099947440863086225782187112663809, 280290124780175821729678400814355564485, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 229138548907862643092856609226723050075, 140302709094137701773086334180578563688, 127044987962124214100696270195559210814, 260950720930659604756740365450507371663, 301648155472379285594517050531127483548, 135217442928347349540220511812067137647, 127044987962124214100696270195559210814, 75371056103973480373443517203033791314, 330443362254714811278522520670919771869, 132117099947440863086225782187112663809, 301648155472379285594517050531127483548, 132117099947440863086225782187112663809, 52025852590564328496031723616521325469, 101473043316046160883738884593606957434, 57512852240092789512489991536185408584, 260950720930659604756740365450507371663, 75371056103973480373443517203033791314, 127360297788558372456973998053019048669, 135217442928347349540220511812067137647, 140302709094137701773086334180578563688, 312483091106876729395161500591121481064, 57512852240092789512489991536185408584, 132117099947440863086225782187112663809, 52025852590564328496031723616521325469, 75371056103973480373443517203033791314, 57512852240092789512489991536185408584, 57512852240092789512489991536185408584, 301648155472379285594517050531127483548, 140175431361313732288440547599619953992, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 268343242210070543641525550351035429524, 301648155472379285594517050531127483548, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 301648155472379285594517050531127483548, 135217442928347349540220511812067137647, 330443362254714811278522520670919771869, 132117099947440863086225782187112663809, 302282648683284548814202807340787655613, 139335500873816609567900312949843139873, 268343242210070543641525550351035429524, 135217442928347349540220511812067137647, 57512852240092789512489991536185408584, 132117099947440863086225782187112663809, 135217442928347349540220511812067137647, 57512852240092789512489991536185408584, 132117099947440863086225782187112663809, 301648155472379285594517050531127483548, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 75371056103973480373443517203033791314, 229138548907862643092856609226723050075, 127360297788558372456973998053019048669, 75371056103973480373443517203033791314, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 229138548907862643092856609226723050075, 140302709094137701773086334180578563688, 330443362254714811278522520670919771869, 75371056103973480373443517203033791314, 328441037604453537976363247914938474182, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 140302709094137701773086334180578563688, 132117099947440863086225782187112663809, 169393384228144871625990433807197966773, 217694107356916866121607052237984398603, 75371056103973480373443517203033791314, 301648155472379285594517050531127483548, 57512852240092789512489991536185408584, 75371056103973480373443517203033791314, 132117099947440863086225782187112663809, 330443362254714811278522520670919771869, 140302709094137701773086334180578563688, 127044987962124214100696270195559210814, 285106641514631128245889883706054218556, 260950720930659604756740365450507371663, 132117099947440863086225782187112663809, 260950720930659604756740365450507371663, 75371056103973480373443517203033791314, 217694107356916866121607052237984398603, 217694107356916866121607052237984398603, 132117099947440863086225782187112663809, 301648155472379285594517050531127483548, 127044987962124214100696270195559210814, 101473043316046160883738884593606957434, 140302709094137701773086334180578563688, 127044987962124214100696270195559210814, 75371056103973480373443517203033791314, 289548202804218369273708443831392368399, 132117099947440863086225782187112663809, 165799207128434858641672726827070059029, 334755564751598048042394781213255939012, 335344749019279195985775024993445213947, 301423883473918993177634428163190101268, 42767516990368493138776584305024125808, 324787361952219506718126426467652498112, 53459933652527578064242465506376923016, 75371056103973480373443517203033791314, 169393384228144871625990433807197966773, 217694107356916866121607052237984398603, 204791166937441563272975036703176244680, 229138548907862643092856609226723050075, 75371056103973480373443517203033791314, 52025852590564328496031723616521325469, 53459933652527578064242465506376923016, 127044987962124214100696270195559210814, 260950720930659604756740365450507371663, 82324359399928500054185503234815398877, 302282648683284548814202807340787655613, 289548202804218369273708443831392368399, 132117099947440863086225782187112663809, 67435298396569627229809714987765527069, 140302709094137701773086334180578563688, 10477030623836167233684437098032507967, 132117099947440863086225782187112663809, 57512852240092789512489991536185408584, 260950720930659604756740365450507371663, 127360297788558372456973998053019048669, 301648155472379285594517050531127483548, 127044987962124214100696270195559210814, 140175431361313732288440547599619953992, 75371056103973480373443517203033791314, 32129299595146848534093479265394572654, 281595222973318803755638905082365601824, 281595222973318803755638905082365601824, 301423883473918993177634428163190101268, 312483091106876729395161500591121481064, 127360297788558372456973998053019048669, 75371056103973480373443517203033791314, 135217442928347349540220511812067137647, 57512852240092789512489991536185408584, 101473043316046160883738884593606957434, 301648155472379285594517050531127483548]

flag = ""
for c in enc:
    for i in range(len(md5_chrs)):
        if c == md5_chrs[i]:
            flag += chr(i)

print(flag)

"""
Wednesday, 11/8, clear skies. This morning, I had breakfast at my favorite cafe. Drinking the freshly brewed coffee and savoring the warm buttery toast is the best. Changing the subject, I received an email today with something rather peculiar in it. It contained a mysterious message that said "This is a secret code, so please don't tell anyone. FLAG{13epl4cem3nt}". How strange!

Gureisya
"""
```
Flag: *FLAG{13epl4cem3nt}*

## Easy calc
### Description:
😆

### Attachment:
*chall.py*
```python
import os
import random
from hashlib import md5

from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes, getPrime

FLAG = os.getenvb(b"FLAG", b"FAKE{THIS_IS_NOT_THE_FLAG!!!!!!}")


def encrypt(m: bytes, key: int) -> bytes:
    iv = os.urandom(16)
    key = long_to_bytes(key)
    key = md5(key).digest()
    cipher = AES.new(key, AES.MODE_CBC, iv=iv)
    return iv + cipher.encrypt(m)


def f(s, p):
    u = 0
    for i in range(p):
        u += p - i
        u *= s
        u %= p

    return u


p = getPrime(1024)
s = random.randint(1, p - 1)

A = f(s, p)
ciphertext = encrypt(FLAG, s).hex()

print(f"{p = }")
print(f"{A = }")
print(f"{ciphertext = }")
```

*output.txt*
```
p = 108159532265181242371960862176089900437183046655107822712736597793129430067645352619047923366465213553080964155205008757015024406041606723580700542617009651237415277095236385696694741342539811786180063943404300498027896890240121098409649537982185247548732754713793214557909539077228488668731016501718242238229
A = 60804426023059829529243916100868813693528686280274100232668009387292986893221484159514697867975996653561494260686110180269479231384753818873838897508257692444056934156009244570713404772622837916262561177765724587140931364577707149626116683828625211736898598854127868638686640564102372517526588283709560663960
ciphertext = '9fb749ef7467a5aff04ec5c751e7dceca4f3386987f252a2fc14a8970ff097a81fcb1a8fbe173465eecb74fb1a843383'
```

### Analysis:
Ở bài này, hàm mã hóa của chúng ta như sau:
```python
def encrypt(m: bytes, key: int) -> bytes:
    iv = os.urandom(16)
    key = long_to_bytes(key)
    key = md5(key).digest()
    cipher = AES.new(key, AES.MODE_CBC, iv=iv)
    return iv + cipher.encrypt(m)
```

Hàm này sử dụng mã hóa AES_CBC, với key truyền vào sẽ được hash MD5. Nói chung là không có gì đặc biệt.
```python
p = getPrime(1024)
s = random.randint(1, p - 1)

A = f(s, p)
ciphertext = encrypt(FLAG, s).hex()
```

Ở đây ta thấy `p` là một số nguyên tố 1024-bits, `s` là một số nguyên ngẫu nhiên từ 1 cho đến p-1. Sau đó 2 tham số này sẽ được truyền vào hàm `f(s, p)` để tính ra `A`. Cuối cùng ciphertext sẽ được mã hóa với key là `s`. Vậy có vẻ mục đích của chúng ta sẽ là phải tính được `s`.

Hãy cùng phân tích về hàm có liên quan tới `s` là hàm `f(s, p)`:
```python
def f(s, p):
    u = 0
    for i in range(p):
        u += p - i
        u *= s
        u %= p

    return u
```

Hãy nhớ rằng đề bài đã cho chúng ta biết giá trị của `A` và `p`, nên ta sẽ phải tìm cách lấy được `s` từ hàm này. Nhìn qua thì nó có vẻ khá là khó dịch ngược, khi ta thao tác biến đổi `u` tận `p` lần, khi `p` là vô cùng lớn. Tuy nhiên, hãy thử lấy giấy bút ra và phân tích từng vòng lặp.

Đối với vòng lặp đầu tiên (hay i = 0):

$$ u \equiv ps \pmod{p} $$

Sang vòng lặp thứ hai:

$$ u \equiv ps^2 + (p-1)s \pmod{p} $$

Vòng lặp thứ ba:

$$ u \equiv ps^3 + (p-1)s^2 + (p-2)s \pmod{p} $$

Đến đây thì rõ ràng, mình có thể xác định được sau `p` vòng lặp, ta sẽ có biểu thức sau:

$$ u \equiv ps^p + (p-1)s^{p-1} + (p-2)s^{p-2} + .... + 2s^2 + s \pmod{p} $$

Với biểu thức này, mình sẽ sử dụng công thức tổng của một loại dãy số có cả tính chất của cấp số cộng và cấp số nhân, hay [**Arithmetic-Geometric Progression (AGP)**](https://brilliant.org/wiki/arithmetic-geometric-progression/)

Cụ thể, với một dãy số dạng như sau:

$$a, (a+d)r, (a+2d)r^2, (a+3d)r^3,...,[a+(n-1)d]r^{n-1} $$ 

Mình sẽ có công thức tính tổng của nó là:

$$ S_n = \frac{a-[a+(n-1)d]r^n}{1-r} + \frac{dr(1-r^{n-1})}{(1-r)^2} $$

Áp dụng đối với biểu thức của chúng ta, dễ dàng có thể thấy `a = 0, d = 1, n = p + 1, r = s`. Từ đó, áp dụng công thức tính tổng, ta sẽ thu được biểu thức như sau:

$$ u \equiv \frac{0-[0+(p+1-1).1]s^{p+1}}{1-s} + \frac{1.s(1-s^{p+1-1})}{(1-s)^2} \pmod{p} $$  

$$ \Leftrightarrow u \equiv -\frac{ps^{p+1}}{1-s} + \frac{s(1-s^{p})}{(1-s)^2} \pmod{p} $$  

$$ \Leftrightarrow u \equiv \frac{s - s^{p+1} - (1-s)ps^{p+1}}{(1-s)^2} \pmod{p} $$  

$$ \Leftrightarrow u \equiv \frac{ps^{p+2} - (p+1)s^{p+1} + s}{(1-s)^2} \pmod{p} $$  


Đến đây, do `p` là số nguyên tố, ta sẽ áp dụng định lý Fermat nhỏ, **Fermat's little theorem**. Khi $p$ là số nguyên tố, với mọi số nguyên $a$ ta luôn có $ a^p \equiv a \pmod{p} $. Xét vào tử số của biểu thức u, ta thấy:

$$ ps^{p+2} \equiv 0.s^3 \equiv 0 \pmod{p} $$  

$$ (p+1)s^{p+1} \equiv 1.s^2 \equiv s^2  \pmod{p} $$  


Vậy ta sẽ có như sau:

$$ u \equiv \frac{s-s^2}{(1-s)^2} \pmod{p} $$  

$$ \Leftrightarrow u \equiv \frac{s}{1-s} \pmod{p} $$  

$$ \Leftrightarrow s \equiv \frac{u}{1+u} \pmod{p} $$  


Từ đây, ta có thể dễ dàng tính được `s` sử dụng công thức trên và giải mã flag.

**Note:** Nên nhớ trong trường hữu hạn, ta sẽ phải tính như sau (bên trên là do mình phân tích do dễ hiểu):
$$ s \equiv u(u+1)^{-1} \pmod{p} $$


### Solution:
```python
from hashlib import md5
from Crypto.Cipher import AES
from Crypto.Util.number import *

p = 108159532265181242371960862176089900437183046655107822712736597793129430067645352619047923366465213553080964155205008757015024406041606723580700542617009651237415277095236385696694741342539811786180063943404300498027896890240121098409649537982185247548732754713793214557909539077228488668731016501718242238229
A = 60804426023059829529243916100868813693528686280274100232668009387292986893221484159514697867975996653561494260686110180269479231384753818873838897508257692444056934156009244570713404772622837916262561177765724587140931364577707149626116683828625211736898598854127868638686640564102372517526588283709560663960
ciphertext = '9fb749ef7467a5aff04ec5c751e7dceca4f3386987f252a2fc14a8970ff097a81fcb1a8fbe173465eecb74fb1a843383'

iv = bytes.fromhex(ciphertext[:32])
c = bytes.fromhex(ciphertext[32:])

s = A*inverse(1+A, p) % p 

key = long_to_bytes(s)
key = md5(key).digest()
cipher = AES.new(key, AES.MODE_CBC, iv=iv)
print(cipher.decrypt(c))
```
Flag: *FLAG{Do_the_math396691ba7d7270a}*

## dance
### Description:
step by step

### Attachments:
*chall.py*
```python
from mycipher import MyCipher
import hashlib
import datetime
import random

isLogged = False
current_user = ''
d = {}

def make_token(data1: str, data2: str):
    sha256 = hashlib.sha256()
    sha256.update(data1.encode())
    right = sha256.hexdigest()[:20]
    sha256.update(data2.encode())
    left = sha256.hexdigest()[:12]
    token = left + right
    return token

def main():
    print('Welcome to the super secure encryption service!')
    while True:
        print('Select an option:')
        print('1. Register')
        print('2. Login')
        print('3. Logout')
        print('4. Encrypt')
        print('5. Exit')
        choice = input('> ')
        if choice == '1':
            Register()
        elif choice == '2':
            Login()
        elif choice == '3':
            Logout()
        elif choice == '4':
            Encrypt()
        elif choice == '5':
            print('Goodbye!')
            break
        else:
            print('Invalid choice')

def Register():
    global d
    username = input('Enter username: ')
    if username in d:
        print('Username already exists')
        return
    dt_now = datetime.datetime.now()
    minutes = dt_now.minute
    sec = dt_now.second
    data1 = f'user: {username}, {minutes}:{sec}'
    data2 = f'{username}'+str(random.randint(0, 10))
    d[username] = make_token(data1, data2)
    print('Registered successfully!')
    print('Your token is:', d[username])
    return

def Login():
    global isLogged
    global d
    global current_user
    username = input('Enter username: ')
    if username not in d:
        print('Username does not exist')
        return
    token = input('Enter token: ')
    if d[username] != token:
        print('Invalid token')
        return
    isLogged = True
    current_user = username
    print(f'Logged in successfully! Hi {username}!')
    return

def Logout():
    global isLogged
    global current_user
    isLogged = False
    current_user = ''
    print('Logged out successfully!')
    return

def Encrypt():
    global isLogged
    global current_user
    if not isLogged:
        print('You need to login first')
        return
    token = d[current_user]
    sha256 = hashlib.sha256()
    sha256.update(token.encode())
    key = sha256.hexdigest()[:32]
    nonce = token[:12]
    cipher = MyCipher(key.encode(), nonce.encode())
    plaintext = input('Enter plaintext: ')
    ciphertext = cipher.encrypt(plaintext.encode())
    print('username:', current_user)
    print('Ciphertext:', ciphertext.hex())
    return

if __name__ == '__main__':
    main()
```

*mycipher.py*
```python
from utils import *

class MyCipher:
    def __init__(self, key: bytes, nonce: bytes):
        self.key = key
        self.nonce = nonce
        self.counter = 1
        self.state = List[F2_32]

    def __quarter_round(self, a: F2_32, b: F2_32, c: F2_32, d: F2_32):
        a += b; d ^= a; d <<= 16
        c += d; b ^= c; b <<= 12
        a += b; d ^= a; d <<= 8
        c += d; b ^= c; b <<= 7
        return a, b, c, d
    
    def __Qround(self, idx1, idx2, idx3, idx4):
        self.state[idx1], self.state[idx2], self.state[idx3], self.state[idx4] = \
            self.__quarter_round(self.state[idx1], self.state[idx2], self.state[idx3], self.state[idx4])

    def __update_state(self):
        for _ in range(10):
            self.__Qround(0, 4, 8, 12)
            self.__Qround(1, 5, 9, 13)
            self.__Qround(2, 6, 10, 14)
            self.__Qround(3, 7, 11, 15)
            self.__Qround(0, 5, 10, 15)
            self.__Qround(1, 6, 11, 12)
            self.__Qround(2, 7, 8, 13)
            self.__Qround(3, 4, 9, 14)

    def __get_key_stream(self, key: bytes, counter: int, nonce: bytes) -> bytes:
        constants = [F2_32(x) for x in struct.unpack('<IIII', b'expand 32-byte k')]
        key = [F2_32(x) for x in struct.unpack('<IIIIIIII', key)]
        counter = [F2_32(counter)]
        nonce = [F2_32(x) for x in struct.unpack('<III', nonce)]
        self.state = constants + key + counter + nonce
        initial_state = self.state[:]
        self.__update_state()
        self.state = [x + y for x, y in zip(self.state, initial_state)]
        return serialize(self.state)
    
    def __xor(self, a: bytes, b: bytes) -> bytes:
        return bytes([x ^ y for x, y in zip(a, b)])

    def encrypt(self, plaintext: bytes) -> bytes:
        encrypted_message = bytearray(0)

        for i in range(len(plaintext)//64):
            key_stream = self.__get_key_stream(self.key, self.counter + i, self.nonce)
            encrypted_message += self.__xor(plaintext[i*64:(i+1)*64], key_stream)

        if len(plaintext) % 64 != 0:
            key_stream = self.__get_key_stream(self.key, self.counter + len(plaintext)//64, self.nonce)
            encrypted_message += self.__xor(plaintext[(len(plaintext)//64)*64:], key_stream[:len(plaintext) % 64])

        return bytes(encrypted_message)
```

*utils.py*
```python
import struct
from typing import List

class F2_32:
    def __init__(self, val: int):
        self.val = val & 0xffffffff
    def __add__(self, other):
        return F2_32(self.val + other.val)
    def __sub__(self, other):
        return F2_32(self.val - other.val + 0xffffffff + 1)
    def __xor__(self, other):
        return F2_32(self.val ^ other.val)
    def __lshift__(self, nbit: int):
        left = (self.val << nbit) & 0xffffffff
        right = (self.val & 0xffffffff) >> (32 - nbit)
        return F2_32(left | right)
    def __rshift__(self, nbit: int):
        left = (self.val & 0xffffffff) >> nbit
        right = (self.val << (32 - nbit)) & 0xffffffff
        return F2_32(left | right)
    def __repr__(self):
        return hex(self.val)
    def __int__(self):
        return int(self.val)
    
def serialize(state: List[F2_32]) -> List[bytes]:
    return b''.join([ struct.pack('<I', int(s)) for s in state ])
```

*output.txt*
```
username = 'gureisya'
ciphertext = '061ff06da6fbf8efcd2ca0c1d3b236aede3f5d4b6e8ea24179'
```

### Analysis:
Ở bài này ta sẽ có một server với nhiều chức năng. Trước hết là chức năng `Register`:
```python
def Register():
    global d
    username = input('Enter username: ')
    if username in d:
        print('Username already exists')
        return
    dt_now = datetime.datetime.now()
    minutes = dt_now.minute
    sec = dt_now.second
    data1 = f'user: {username}, {minutes}:{sec}'
    data2 = f'{username}'+str(random.randint(0, 10))
    d[username] = make_token(data1, data2)
    print('Registered successfully!')
    print('Your token is:', d[username])
    return
```

Hàm này sẽ cho người dùng nhập vào tên và sau đó sẽ gen ra 2 chuỗi. Giả sử tên người dùng là PTU, ta sẽ có:
```
data1 = "user: PTU, MM:SS" với MM, SS là phút, giây của thời gian hiện tại
data2 = "PTU:X" với X random từ (0,10) 
```

Từ hai chuỗi trên, chương trình sẽ gen ra một token sử dụng hàm sau:
```python
def make_token(data1: str, data2: str):
    sha256 = hashlib.sha256()
    sha256.update(data1.encode())
    right = sha256.hexdigest()[:20]
    sha256.update(data2.encode())
    left = sha256.hexdigest()[:12]
    token = left + right
    return token
```

Hàm này sẽ tiến hành lấy SHA256 của 2 chuỗi vừa được tạo. Với chuỗi `data1`, ta sẽ lấy 20 kí tự đầu của SHA256 của nó. Với chuỗi `data2`, ta sẽ lấy 12 kí tự đầu của SHA256 của nó. Token sẽ là ghép lại của 32 kí tự trên.

Dễ thấy từ bước này, ta đã có thể dễ dàng brute-force token, do MM, SS chỉ trong khoảng 60 và X từ 0-10. Ta sẽ có 60.60.10 = 36000 trường hợp, khá nhỏ.

Tiếp theo là hàm login và logout:
```python
def Login():
    global isLogged
    global d
    global current_user
    username = input('Enter username: ')
    if username not in d:
        print('Username does not exist')
        return
    token = input('Enter token: ')
    if d[username] != token:
        print('Invalid token')
        return
    isLogged = True
    current_user = username
    print(f'Logged in successfully! Hi {username}!')
    return

def Logout():
    global isLogged
    global current_user
    isLogged = False
    current_user = ''
    print('Logged out successfully!')
    return
```

Hai hàm này thì không có gì thú vị. Hàm `Login` chỉ đơn giản là kiểm tra xem tên người dùng đã tồn tại hay chưa, sau đó nó sẽ check token của user. Nếu đúng thì sẽ login thành công.

Cuối cùng là chức năng `Encrypt`:
```python
def Encrypt():
    global isLogged
    global current_user
    if not isLogged:
        print('You need to login first')
        return
    token = d[current_user]
    sha256 = hashlib.sha256()
    sha256.update(token.encode())
    key = sha256.hexdigest()[:32]
    nonce = token[:12]
    cipher = MyCipher(key.encode(), nonce.encode())
    plaintext = input('Enter plaintext: ')
    ciphertext = cipher.encrypt(plaintext.encode())
    print('username:', current_user)
    print('Ciphertext:', ciphertext.hex())
    return
```

Hàm này sẽ cho phép người dùng nhập vào plaintext và in ra username và ciphertext. Key của hàm mã hóa này sẽ là SHA256 của token, lấy 32 kí tự đầu. Nonce của hàm này là 12 kí tự đầu của token. Dựa trên việc ta có thể brute-force được token như mình đã nói ở trên, `key` và `nonce` hoàn toàn có thể tính được.

Nhìn vào file *output.txt*, có thể thấy ta sẽ phải giải mã ciphertext của user `gureisya`. Để có thể giải mã, ta phải xem hàm mã hóa của nó như nào. Nhìn vào file `MyCipher`, thực chất các bạn không cần phải hiểu rõ từng hàm mà chỉ cần để ý hàm mã hóa:
```python
def encrypt(self, plaintext: bytes) -> bytes:
        encrypted_message = bytearray(0)

        for i in range(len(plaintext)//64):
            key_stream = self.__get_key_stream(self.key, self.counter + i, self.nonce)
            encrypted_message += self.__xor(plaintext[i*64:(i+1)*64], key_stream)

        if len(plaintext) % 64 != 0:
            key_stream = self.__get_key_stream(self.key, self.counter + len(plaintext)//64, self.nonce)
            encrypted_message += self.__xor(plaintext[(len(plaintext)//64)*64:], key_stream[:len(plaintext) % 64])

        return bytes(encrypted_message)
```

Hàm này thực hiện XOR plaintext với keystream, có thể nói đây là một dạng stream cipher, cho nên hàm encrypt sẽ chính là hàm decrypt luôn.

Vậy chung quy lại, ta chỉ cần bruteforce token của user `gureisya`, sau đó đưa vào hàm `encrypt` là có thể lấy được flag.

### Solution:
```python
import hashlib
from mycipher import MyCipher

username = 'gureisya'
ciphertext = '061ff06da6fbf8efcd2ca0c1d3b236aede3f5d4b6e8ea24179'

def make_token(data1: str, data2: str):
    sha256 = hashlib.sha256()
    sha256.update(data1.encode())
    right = sha256.hexdigest()[:20]
    sha256.update(data2.encode())
    left = sha256.hexdigest()[:12]
    token = left + right
    return token

for i in range(0,60):
    for j in range(0, 60):
        for k in range(0, 11):
            data1 = f'user: {username}, {str(i):02}:{str(j):02}'
            data2 = f'{username}' + str(k)
            token = make_token(data1, data2)

            sha256 = hashlib.sha256()
            sha256.update(token.encode())
            key = sha256.hexdigest()[:32]
            nonce = token[:12]

            cipher = MyCipher(key.encode(), nonce.encode())
            plaintext = cipher.encrypt(bytes.fromhex(ciphertext))
            
            if b'FLAG' in plaintext:
                print(plaintext)
```
Flag: *FLAG{d4nc3_l0b0t_d4nc3!!}*

## speedy
### Description:
I made a super speedy keystream cipher!!

### Attachments:
*chall.py*
```python
from cipher import MyCipher
from Crypto.Util.number import *
from Crypto.Util.Padding import *
import os

s0 = bytes_to_long(os.urandom(8))
s1 = bytes_to_long(os.urandom(8))

cipher = MyCipher(s0, s1)
secret = b'FLAG{'+b'*'*19+b'}'
pt = pad(secret, 8)
ct = cipher.encrypt(pt)
print(f'ct = {ct}')
```

*cipher.py*
```python
from Crypto.Util.number import *
from Crypto.Util.Padding import *

def rotl(x, y):
    x &= 0xFFFFFFFFFFFFFFFF
    return ((x << y) | (x >> (64 - y))) & 0xFFFFFFFFFFFFFFFF

class MyCipher:
    def __init__(self, s0, s1):
        self.X = s0
        self.Y = s1
        self.mod = 0xFFFFFFFFFFFFFFFF
        self.BLOCK_SIZE = 8
    
    def get_key_stream(self):
        s0 = self.X
        s1 = self.Y
        sum = (s0 + s1) & self.mod
        s1 ^= s0
        key = []
        for _ in range(8):
            key.append(sum & 0xFF)
            sum >>= 8
        
        self.X = (rotl(s0, 24) ^ s1 ^ (s1 << 16)) & self.mod
        self.Y = rotl(s1, 37) & self.mod
        return key
    
    def encrypt(self, pt: bytes):
        ct = b''
        for i in range(0, len(pt), self.BLOCK_SIZE):
            ct += long_to_bytes(self.X)
            key = self.get_key_stream()
            block = pt[i:i+self.BLOCK_SIZE]
            ct += bytes([block[j] ^ key[j] for j in range(len(block))])
        return ct
```

*out.txt*
```
ct = b'"G:F\xfe\x8f\xb0<O\xc0\x91\xc8\xa6\x96\xc5\xf7N\xc7n\xaf8\x1c,\xcb\xebY<z\xd7\xd8\xc0-\x08\x8d\xe9\x9e\xd8\xa51\xa8\xfbp\x8f\xd4\x13\xf5m\x8f\x02\xa3\xa9\x9e\xb7\xbb\xaf\xbd\xb9\xdf&Y3\xf3\x80\xb8'
```

### Analysis:
Ở bài này, ta sẽ có 2 số random 64-bits `s0`, `s1` (không thể bruteforce) là 2 tham số để đưa vào class `MyCipher` để mã hóa flag.
```python
s0 = bytes_to_long(os.urandom(8))
s1 = bytes_to_long(os.urandom(8))

cipher = MyCipher(s0, s1)
secret = b'FLAG{'+b'*'*19+b'}'
pt = pad(secret, 8)
ct = cipher.encrypt(pt)
print(f'ct = {ct}')
```

Hãy cùng nhìn vào class này xem có gì hay ho. Đầu tiên ta có các giá trị khởi tạo:
```python
def __init__(self, s0, s1):
        self.X = s0
        self.Y = s1
        self.mod = 0xFFFFFFFFFFFFFFFF
        self.BLOCK_SIZE = 8
```

`s0` sẽ được gán vào `X` và `s1` sẽ được gán vào `Y`. Biến `mod` có vẻ là để giữ cho các phép tính luôn trả về giá trị 64-bits và `BLOCK_SIZE` ở đây là 8, có vẻ ta sẽ có một dạng mã hóa khối. Đến với hàm tạo khóa:
```python
def get_key_stream(self):
        s0 = self.X
        s1 = self.Y
        sum = (s0 + s1) & self.mod
        s1 ^= s0
        key = []
        for _ in range(8):
            key.append(sum & 0xFF)
            sum >>= 8
        
        self.X = (rotl(s0, 24) ^ s1 ^ (s1 << 16)) & self.mod
        self.Y = rotl(s1, 37) & self.mod
        return key
```

Ta có thể thấy biến `s0` được gán giá trị của `X`, `s1` được gán giá trị của `Y`. Vậy 2 biến này cũng sẽ có giá trị như 2 biến `s0`, `s1` ta truyền vào class. Tiếp theo, tổng của 2 giá trị này sẽ được tính gán vào `sum`, sau đó `s0` sẽ được xor với `s1`. Một keystream dài 8-bytes sẽ được tạo ra với mỗi byte được tính bằng cách lấy byte cuối cùng của `sum`, và dịch phải `sum` 8-bits. Có thể nhận ra nó chỉ là lấy từng bytes của sum ra, từ cuối lên, làm keystream. 

Sau khi keystream được tạo, X và Y sẽ được biến đổi để đảm bảo tạo ra keystream khác nhau mỗi lần gọi. 
```python
self.X = (rotl(s0, 24) ^ s1 ^ (s1 << 16)) & self.mod
self.Y = rotl(s1, 37) & self.mod
```

Các thao tác này bao gồm xor, quay trái và dịch trái. Chúng đều có thể được reverse nếu muốn. Cuối cùng là hàm `encrypt`:
```python
def encrypt(self, pt: bytes):
        ct = b''
        for i in range(0, len(pt), self.BLOCK_SIZE):
            ct += long_to_bytes(self.X)
            key = self.get_key_stream()
            block = pt[i:i+self.BLOCK_SIZE]
            ct += bytes([block[j] ^ key[j] for j in range(len(block))])
        return ct
```

Hàm này sẽ chia plaintext ra thành từng chuỗi 8-bytes. Và ciphertext sẽ được tạo ra lần lượt như sau:

- Thêm giá trị của `X` vào ciphertext
- Tạo keystream
- Thêm giá trị của `block^key` vào ciphertext.
- Lặp lại cho tới khi hết các block.

Đến đây thì ta có thể để ý một số thứ rằng:

- Do `X` được in trước khi tạo keystream lần đầu, nên byte đầu tiên trong ciphertext chính là `s0`
- `X` thứ hai sẽ là ở byte thứ 9 và nó là `(rotl(s0, 24) ^ s1 ^ (s1 << 16)) & self.mod`
- Ta có thể dễ dàng tính được `s1 ^ (s1 << 16) = rotl(s0, 24) ^ X` và tính ra `s1` (cái này các bạn xem hàm mình dùng để reverse và ghi ra giấy sẽ hiểu)

Khi đã có `s0` và `s1`, mọi chuyện sẽ chả còn gì nữa. Ta chỉ cần tạo lại keystream và xor với các block tương ứng là có thể lấy được flag.

Để ý là ta sẽ chia ciphertext ra thành các block 9-bytes và bỏ đi byte đầu tiên, nó sẽ là các block đúng.

### Solution:
```python
from Crypto.Util.number import *
from Crypto.Util.Padding import *
from pwn import *

ct = b'"G:F\xfe\x8f\xb0<O\xc0\x91\xc8\xa6\x96\xc5\xf7N\xc7n\xaf8\x1c,\xcb\xebY<z\xd7\xd8\xc0-\x08\x8d\xe9\x9e\xd8\xa51\xa8\xfbp\x8f\xd4\x13\xf5m\x8f\x02\xa3\xa9\x9e\xb7\xbb\xaf\xbd\xb9\xdf&Y3\xf3\x80\xb8'

def rotl(x, y):
    x &= 0xFFFFFFFFFFFFFFFF
    return ((x << y) | (x >> (64 - y))) & 0xFFFFFFFFFFFFFFFF

blocks = []
for i in range(0, 64, 16):
    blocks.append(ct[i:i+16])

states = [block[0:8] for block in blocks]

cs = [block[8:] for block in blocks]

# self.X = (rotl(s0, 24) ^ s1 ^ (s1 << 16)) & self.mod
s0 = bytes_to_long(states[0])
X = bytes_to_long(states[1])

def rev_xor_shift_left_func(data):
    data = format(data, "064b")
    data = data[::-1]
    cal_data = [0]*16
    for i in range(64):
        cal_data.append(cal_data[i] ^ int(data[i]))
    cal_data = cal_data[16:]
    cal_data = cal_data[::-1]
    return int("".join(str(i) for i in cal_data), 2)

data = (rotl(s0, 24) ^ X) & 0xFFFFFFFFFFFFFFFF
s1 = rev_xor_shift_left_func(data) ^ s0
print(s0)
print(s1)

class MyCipher:
    def __init__(self, s0, s1):
        self.X = s0
        self.Y = s1
        self.mod = 0xFFFFFFFFFFFFFFFF
        self.BLOCK_SIZE = 8
    
    def get_key_stream(self):
        s0 = self.X
        s1 = self.Y
        sum = (s0 + s1) & self.mod
        s1 ^= s0
        key = []
        for _ in range(8):
            key.append(sum & 0xFF)
            sum >>= 8
        
        self.X = (rotl(s0, 24) ^ s1 ^ (s1 << 16)) & self.mod
        self.Y = rotl(s1, 37) & self.mod
        return key
    
    def encrypt(self, pt: bytes):
        ct = b''
        for i in range(0, len(pt), self.BLOCK_SIZE):
            ct += long_to_bytes(self.X)
            key = self.get_key_stream()
            block = pt[i:i+self.BLOCK_SIZE]
            ct += bytes([block[j] ^ key[j] for j in range(len(block))])
        return ct

    def getKey(self):
        keys = []
        for _ in range(4):
            key = self.get_key_stream()
            keys.append(key)
        return keys
    
cipher = MyCipher(s0, s1)

secret = b'FLAG{'+b'*'*19+b'}'
pt = pad(secret, 8)
keys = cipher.getKey()

flag = b''
for i in range(4):
    flag += xor(cs[i],keys[i])

print(unpad(flag, 8))
```
Flag: *FLAG{x013_ro74te_5hif7!!}*

## Many Xor Shift
### Description:
Memories of long long ago.

### Attachments:
*chall.py*
```python
FLAG = b'FAKE{XXXXXXXXXXXXXXXXXXXXXX}'

N = 7
M = 17005450388330379
WORD_SIZE = 32
WORD_MASK = (1 << WORD_SIZE) - 1

def encrypt(m):
    state = [int.from_bytes(m[i:i+4]) for i in range(0, len(m), 4)]
    assert len(state) == N # len(flag) từ 25-28
    # state[0] = int.frombytes(b'FLAG')

    def xor_shift():
        nonlocal state
        t = state[0] ^ ((state[0] << 11) & WORD_MASK)
        for i in range(N-1):
            state[i] = state[i+1]
        state[-1] = (state[-1] ^ (state[-1] >> 19)) ^ (t ^ (t >> 8))

    for _ in range(M):
        xor_shift()

    return state

print("N = ", N)
print("M = ", M)
print("WORD_SIZE = ", WORD_SIZE)
print("state = ", encrypt(FLAG))
```

*output.txt*
```
N = 7
M = 17005450388330379
WORD_SIZE = 32
state = [1927245640, 871031439, 789877080, 4042398809, 3950816575, 2366948739, 935819524]
```

### Analysis:
Ở bài này, trước tiên ta sẽ có một số tham số khởi tạo như sau:
```python
N = 7
M = 17005450388330379
WORD_SIZE = 32
WORD_MASK = (1 << WORD_SIZE) - 1
```

`WORD_MASK` sẽ đảm bảo các kết quả không vượt quá 32-bits. Tiếp theo ta sẽ phân tích từng phần hàm mã hóa.
```python
state = [int.from_bytes(m[i:i+4]) for i in range(0, len(m), 4)]
    assert len(state) == N
```
Đầu tiên, một mảng `state` sẽ được tạo ra với mỗi phần tử là 4-bytes của plaintext. Assert cho thấy mảng này sẽ có 7 phần tử, hay flag của chúng ta sẽ có độ dài khoảng 25-28 bytes. Tiếp theo:
```python
def xor_shift():
        nonlocal state
        t = state[0] ^ ((state[0] << 11) & WORD_MASK)
        for i in range(N-1):
            state[i] = state[i+1]
        state[-1] = (state[-1] ^ (state[-1] >> 19)) ^ (t ^ (t >> 8))

for _ in range(M):
    xor_shift()

return state
```

Hàm này sẽ tính giá trị `t = state[0] ^ ((state[0] << 11) & WORD_MASK)`, sau đó nó sẽ bỏ đi phần tử đầu tiên của mảng và thêm vào một phần tử cuối có giá trị được tính bằng `(state[-1] ^ (state[-1] >> 19)) ^ (t ^ (t >> 8))`. Hàm này sẽ được chạy `M` lần và trả về `state` lúc đó.

Có thể thấy rõ, các operation trong hàm xor_shift đều có thể dễ dàng reverse, giúp ta khôi phục lại dần các state cũ. Tuy nhiên, do `M` rất lớn (17005450388330379), nếu cứ khôi phục dần như vậy, ta sẽ gần như không bao giờ ra được flag.

Giải pháp là sử dụng ma trận, cơ mà để mình nghiên cứu đã :v

## uf
### Description:
🙄

### Attachments:
*chall.py*
```python
import os
from secrets import randbits
from Crypto.Util.number import bytes_to_long


FLAG = os.environb.get(b"FLAG", b"FAKE{THIS_IS_DUMMY_FLAG}")
m = bytes_to_long(FLAG)
assert m.bit_length() >= 512


def encrypt(m: int, n: int = 512) -> int:
    x = 0
    for i in range(n):
        x <<= 1
        x += m * randbits(1)
        if i >= n // 2:
            x ^= randbits(1)
    return x


X = [encrypt(m) for _ in range(4)]
print(X)
```

*output.txt*
```
[6643852762092641655051592752286380661448697120839285262713138738793179330857521051418707355387198243788554658967735136760757552410466512939791351078152197994352930016306075464400264019640466277732596022216246131141036813931972036259910390741311141390889450882074162723823607552591155184799627590418587536982033939537563823, 4495106960532238798978878322218382764459613684889887356979907395021294655849239390809608204284927849117763119933285899077777162943233437728643056322845118660545730870443735090094400144586494098834221418487123653668703665085461676013454922344247818407399456870636622800919629442727075235809213114639237367651539678560390951, 7622226387024225267485603541284038981214490586915816777231024576546652676746968149372915915975325662783469952634025859954515971134032563991925283958708572235632178937041656690377178266198211581176947491463237398083133658483056792368618417698027992083481412961301906342594056438180675328433412539805240307255787971167535638, 1149407465454162408488208063367931363888120160126632926627929705372269921465081968665764846439238807939361247987642326885758277171318666479752274577607727935160689442316433824450832192798328252739495913920016290902086534688608562545166349970831960156036289570935410160077618096614135121287858428753273136461851339553609896]
```

### Analysis:
Ở bài này, ta sẽ có hàm mã hóa như sau:
```python
def encrypt(m: int, n: int = 512) -> int:
    x = 0
    for i in range(n):
        x <<= 1
        x += m * randbits(1)
        if i >= n // 2:
            x ^= randbits(1)
    return x
```
Và ta sẽ có được 4 output của hàm này với input đều là flag. Để dễ hơn thì đầu tiên mình sẽ tạm thời bỏ đi 2 dòng 6,7. Mình sẽ có như sau:
```python
def encrypt(m: int, n: int = 512) -> int:
    x = 0
    for i in range(n):
        x <<= 1
        x += m * randbits(1)
    return x
```
Khi như này, do x sẽ là 1 phương trình luôn chứa `m` bởi đoạn `m * randbits(1)`. Từ đó, ta sẽ có:

$$ \left\{ \begin{array}{l}x_0 = m.y_0 \\ x_1 = m.y_1 \\ x_2 = m.y_2  \\ x_3 = m.y_3 \end{array} \right. $$

Khi này, `m` sẽ là Ước Chung Lớn Nhất (**Greatest Common Divisors**) của 4 output của chúng ta.

Quay lại với 2 dòng code mà mình đã xóa đi:
```python
if i >= n // 2:
    x ^= randbits(1)
```

Nửa sau của output mà mình viết trong trường hợp bên trên sẽ bị xor một cách ngẫu nhiên, gây ra các sai số khác nhau. Ta có thể thấy được phương trình của chúng ta sẽ trở thành dạng như sau:

$$ \left\{ \begin{array}{l}x_0 = m.y_0 + r_0 \\ x_1 = m.y_1 + r_1 \\ x_2 = m.y_2 + r_2 \\ x_3 = m.y_3 + r_3\end{array} \right. $$


Đến đây thì nó sẽ là bài toán **Approximate GCD Problem**. Hiện tại thì mình có thể script-kiddie và solve nhưng mình muốn hiểu hơn về lattice nên sẽ viết sau khi hiểu :v




