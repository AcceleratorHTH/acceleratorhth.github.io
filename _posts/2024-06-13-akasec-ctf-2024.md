---
title: Akasec CTF 2024
description: CTF-Crypto
author: Pr0pylTh10ur4C1L
date: 2024-06-13 15:57:00 +0700
categories: [Capture The Flag]
tags: [Cryptography]
math: true
mermaid: true
---

## Lost
### Description:
Do you know the feelling of losing a part of you !!

### Attachments:
*chall.py*
```python
from random import getrandbits
from Crypto.Util.number import getPrime, bytes_to_long
from SECRET import FLAG

e = 2
p = getPrime(256)
q = getPrime(256)
n = p * q

m = bytes_to_long(FLAG)
cor_m = m - getrandbits(160)

if __name__ == "__main__":
    c = pow(m, e, n)
    print("n = {}\nc = {}\ncor_m = {}".format(n, c, cor_m))
```

*out.txt*
```
n = 5113166966960118603250666870544315753374750136060769465485822149528706374700934720443689630473991177661169179462100732951725871457633686010946951736764639
c = 329402637167950119278220170950190680807120980712143610290182242567212843996710001488280098771626903975534140478814872389359418514658167263670496584963653
cor_m = 724154397787031699242933363312913323086319394176220093419616667612889538090840511507392245976984201647543870740055095781645802588721
```

### Analysis:
Đây là một bài RSA với `e` khá nhỏ (e = 2). Đề bài cho ta biết được `n`, `c` và `cor_m` là message của chúng ta trừ đi một số 160-bits = 20-bytes, có nghĩa là chúng ta sẽ mất khoảng 20-bytes cuối của message. Khi thử chuyển `cor_m` về dạng bytes, mình thu được như sau:

```python
cor_m = 724154397787031699242933363312913323086319394176220093419616667612889538090840511507392245976984201647543870740055095781645802588721

print(long_to_bytes(cor_m))
# AKASEC{c0pp3r5m17h_4774ck_1n_1ov3_v\xb1\x13q\x9f\xe3\xe4\xa1\xe2\x9b\xd5,\xfe\x14\\q\x99\xb9\x0c\xca1
```

Do đã có một phần plaintext, mình sẽ sử dụng **Stereotyped Message** để khôi phục lại phần còn lại của message và có được flag

### Solution:
```python
from Crypto.Util.number import *
from sage.all import *

e = 2
n = 5113166966960118603250666870544315753374750136060769465485822149528706374700934720443689630473991177661169179462100732951725871457633686010946951736764639
c = 329402637167950119278220170950190680807120980712143610290182242567212843996710001488280098771626903975534140478814872389359418514658167263670496584963653
cor_m = 724154397787031699242933363312913323086319394176220093419616667612889538090840511507392245976984201647543870740055095781645802588721

known = long_to_bytes(cor_m)[:-21]
known_int = bytes_to_long(known)

x = PolynomialRing(Zmod(n), 'x').gen()
f = (known_int * 2**(21 * 8) + x)**e - c
ans = f.small_roots(X = 2**(21 * 8), beta = 0.5)[0]
print(known.decode() + long_to_bytes(int(ans)).decode())
```

Flag: *AKASEC{c0pp3r5m17h_4774ck_1n_1ov3_w17h_5m4ll_3xp0n3nts}*

## Power Over All
### Description:
Power is given only to those who dare to lower themselves and pick it up. Only one thing matters, one thing, to be able to dare!

### Attachments:
*chal.py*
```python
from Crypto.Util.number import getPrime, bytes_to_long
from random import randint
from SECRET import FLAG

def key_gen():
    ps = []
    n = randint(2,2**6)
    for _ in range(n):
        p = getPrime(256)
        ps.append(p)
    return ps

def encrypt(m, ps):
    ps.sort()
    for p in ps:
        e = 1<<1 # 2 
        m = pow(m, e, p)
    return m

if __name__ == "__main__":
    ps = key_gen()
    c = encrypt(bytes_to_long(FLAG), ps)
    print('ps = {}\nc = {}'.format(ps, c))
```

*out.txt*
```
ps = [58320376514263631335873677765253125888698486914776244278840394907785982174227, 58471100903556849464997941473361218814224259836954194397969653104598610032001, 58604272362819290182402155417145974680722885151257754555756391392263925028373, 59492683945798085501800206338526899942899780311409115479365237372756535853291, 62289703300031234585435188246756616897767167359387015636210423567810538226487, 62357776874227535169229603723986677552237575016029450363623522209118965731477, 62742816090727067053274726868556821524033631101402012261515152539681610794161, 63324484395885397762900693586081837883926106660748610230948918800296364184787, 68536318595052838310834810610435117143127088803068602445335475326427140828313, 71333662629967127822322169475282958517332768085026414016527475771426692311137, 71818789628596987832122424763592924131858666988566206124807910367000034628553, 72686903390659724206544737536831534683324964478965218565533472954938736006029, 73733187867854099083339033682720615801689502367745526033697746193463091215391, 74963435458999407861524268290816092282448161750409920047891056819453141955557, 75170120333127044486222669300167892338904422362667312672451826995740967131303, 75389546402724552962462061186170732933053151602764277596760332277139980288183, 76425604829327821607866318415668087016313389323090875428602763671306466213509, 79395489525333852455993920714320320052245084253382013156160044439065839468327, 79656464249999345933529538948250990091001499735972420522175125449790253663599, 80114644787477907454032975169773036722948929091396695518111556258640245353257, 80759006745106776887940527633196344281100618167707846074299752297932178679679, 82874221581479658193940394796733443765246468888210669340444752189895488345711, 84468817045619298841099296118053247701538652785316191917289525698631379587559, 85092225008500173289712181614303627906592443829912221851650912999596788670459, 85263141959763159396039844302970550543465193325499728803392808980592668472247, 85317220893586781914729151221061742320435924332561513947650447739620101821641, 85440269113801669657707134806659364077593365787015642755204798072592063745773, 85527879261087022928016922730880335213911499029647505445360684307006839178647, 85605932852710450456174796386471227136632343649286364769039469217779231567929, 86107819754589869545139506654865763056227887269808133233781131410193748463851, 86163843486640208219217644606617383296879865315755352427047957187159788303323, 90506049416840638351240993555664643907544570698557428055802715993870286417397, 90981593208992230235747480738729958015954461329514397574562251177250355618859, 94292491231252601103954494535972386523808989201770556967497120902651386194197, 94647786177270050686880223709072304737527824812798720504615370320158513996239, 95245024143291248356010627064844329722889005501412707859257139919568967846749, 96080930363425942206733690433078387012542225534990227081492087888246704507441, 97503025379673346416669602471064834261095444529417927406127397664552811080519, 97933089652660434994459543027801105444314465759238615625507952727940600189809, 97989967696425430412414365007330195727579540568089381507635553281304266294483, 98528881400840757343372680020873216862352604380253902505512625033610753437887, 99954243543097817759175467071884308315066389399425962144138323810271659014209, 101194437697606745792831239895049471075868629243259633705095039109106669730049, 104839585136982979038455371159792466832240349600316352323298553695087849421381, 105456177698115744366058226841117004148984862640508652026693415913601327156663, 105968680258458596148231537242426487615777154901757802179920828015643162453013, 107215231310505428676141499322854084705449980120508349014281658724461432400217, 108453510226000323101878638579711809016925129461454736081626840494612032349563, 108912309872075893365304953396355888979232521108447384367848671194555817947569, 108997022694208058790012872910875462503431062529475661062287324154956518493253, 109322568022936420513907683387388159609608845110397725890561824119551381299491, 110029910646386857435917200277309270534213159892118369614262345955187628998231, 113144116692201726589659464242284454643667198002480615110504233499994524508369, 114364819674774846158222033218389865879337160752260853195966728903452922982539, 115473149458023487534963694928189868221104180303262395583076896364124371580681]
c = 53630975642867707857977893429296334474716191527562307357222551886495223105860
```

### Analysis:

Đầu tiên ta có hàm để tạo ra key:
```python
def key_gen():
    ps = []
    n = randint(2,2**6)
    for _ in range(n):
        p = getPrime(256)
        ps.append(p)
    return ps
```

Hàm này chỉ đơn giản là tạo ra `n` số nguyên tố 256-bits, với `n` random trong khoảng từ 2 tới 64. Tiếp đến là hàm mã hóa:

```python
def encrypt(m, ps):
    ps.sort()
    for p in ps:
        e = 1<<1 
        m = pow(m, e, p)
    return m
```

Hàm này sẽ tiến hành sắp xếp các số nguyên tố vừa gen ra, sau đó thực hiện mã hóa message bằng cách lấy `m = m**2 (mod p)` lần lượt với từng số `p`.

Vậy ý tưởng ở đây là ta chỉ cần lấy căn bậc 2 modulo ứng với mỗi p lần lượt từ p lớn nhất tới nhỏ nhất. Kết quả cuối cùng trả về sẽ là flag. Do kết quả trả về của căn bậc 2 sẽ có hai kết quả, ta sẽ cần kiểm tra xem kết quả có phải là thặng dư bậc 2 ứng với số p tiếp theo không để tiếp tục.

### Solution:
```python
from sage.all import *
from Crypto.Util.number import *

ps = [58320376514263631335873677765253125888698486914776244278840394907785982174227, 58471100903556849464997941473361218814224259836954194397969653104598610032001, 58604272362819290182402155417145974680722885151257754555756391392263925028373, 59492683945798085501800206338526899942899780311409115479365237372756535853291, 62289703300031234585435188246756616897767167359387015636210423567810538226487, 62357776874227535169229603723986677552237575016029450363623522209118965731477, 62742816090727067053274726868556821524033631101402012261515152539681610794161, 63324484395885397762900693586081837883926106660748610230948918800296364184787, 68536318595052838310834810610435117143127088803068602445335475326427140828313, 71333662629967127822322169475282958517332768085026414016527475771426692311137, 71818789628596987832122424763592924131858666988566206124807910367000034628553, 72686903390659724206544737536831534683324964478965218565533472954938736006029, 73733187867854099083339033682720615801689502367745526033697746193463091215391, 74963435458999407861524268290816092282448161750409920047891056819453141955557, 75170120333127044486222669300167892338904422362667312672451826995740967131303, 75389546402724552962462061186170732933053151602764277596760332277139980288183, 76425604829327821607866318415668087016313389323090875428602763671306466213509, 79395489525333852455993920714320320052245084253382013156160044439065839468327, 79656464249999345933529538948250990091001499735972420522175125449790253663599, 80114644787477907454032975169773036722948929091396695518111556258640245353257, 80759006745106776887940527633196344281100618167707846074299752297932178679679, 82874221581479658193940394796733443765246468888210669340444752189895488345711, 84468817045619298841099296118053247701538652785316191917289525698631379587559, 85092225008500173289712181614303627906592443829912221851650912999596788670459, 85263141959763159396039844302970550543465193325499728803392808980592668472247, 85317220893586781914729151221061742320435924332561513947650447739620101821641, 85440269113801669657707134806659364077593365787015642755204798072592063745773, 85527879261087022928016922730880335213911499029647505445360684307006839178647, 85605932852710450456174796386471227136632343649286364769039469217779231567929, 86107819754589869545139506654865763056227887269808133233781131410193748463851, 86163843486640208219217644606617383296879865315755352427047957187159788303323, 90506049416840638351240993555664643907544570698557428055802715993870286417397, 90981593208992230235747480738729958015954461329514397574562251177250355618859, 94292491231252601103954494535972386523808989201770556967497120902651386194197, 94647786177270050686880223709072304737527824812798720504615370320158513996239, 95245024143291248356010627064844329722889005501412707859257139919568967846749, 96080930363425942206733690433078387012542225534990227081492087888246704507441, 97503025379673346416669602471064834261095444529417927406127397664552811080519, 97933089652660434994459543027801105444314465759238615625507952727940600189809, 97989967696425430412414365007330195727579540568089381507635553281304266294483, 98528881400840757343372680020873216862352604380253902505512625033610753437887, 99954243543097817759175467071884308315066389399425962144138323810271659014209, 101194437697606745792831239895049471075868629243259633705095039109106669730049, 104839585136982979038455371159792466832240349600316352323298553695087849421381, 105456177698115744366058226841117004148984862640508652026693415913601327156663, 105968680258458596148231537242426487615777154901757802179920828015643162453013, 107215231310505428676141499322854084705449980120508349014281658724461432400217, 108453510226000323101878638579711809016925129461454736081626840494612032349563, 108912309872075893365304953396355888979232521108447384367848671194555817947569, 108997022694208058790012872910875462503431062529475661062287324154956518493253, 109322568022936420513907683387388159609608845110397725890561824119551381299491, 110029910646386857435917200277309270534213159892118369614262345955187628998231, 113144116692201726589659464242284454643667198002480615110504233499994524508369, 114364819674774846158222033218389865879337160752260853195966728903452922982539, 115473149458023487534963694928189868221104180303262395583076896364124371580681]
c = 53630975642867707857977893429296334474716191527562307357222551886495223105860

def is_quadratic_residue(a, p):
    return pow(a, (p - 1) // 2, p) == 1

ps.reverse()
def find_valid_c(ps, c):
    potential_cs = [c]
    for i, p in enumerate(ps):
        next_potential_cs = []
        for c in potential_cs:
            if is_quadratic_residue(c, p):
                Zn = Zmod(p)
                res = Zn(c).sqrt(all=True)
                if len(res) == 2:
                    res0, res1 = int(res[0]), int(res[1])
                    next_potential_cs.append(res0)
                    next_potential_cs.append(res1)
        if not next_potential_cs:
            print(f"No valid c found for p = {p}")
            return None
        potential_cs = next_potential_cs
        print(f"Potential c's after p = {p}: {potential_cs}")
    return potential_cs if potential_cs else None

final_c = find_valid_c(ps, c)
if final_c is not None:
    print(f"Final valid c: {final_c}")
else:
    print("No valid c found for all ps")

for c in final_c:
    flag = long_to_bytes(c)
    if b'AKASEC{' in flag:
        print(flag)
```

Script ngắn hơn (sử dụng dfs)
```python
import sympy as sp
from Crypto.Util.number import *
ps = ps = [58320376514263631335873677765253125888698486914776244278840394907785982174227, 58471100903556849464997941473361218814224259836954194397969653104598610032001, 58604272362819290182402155417145974680722885151257754555756391392263925028373, 59492683945798085501800206338526899942899780311409115479365237372756535853291, 62289703300031234585435188246756616897767167359387015636210423567810538226487, 62357776874227535169229603723986677552237575016029450363623522209118965731477, 62742816090727067053274726868556821524033631101402012261515152539681610794161, 63324484395885397762900693586081837883926106660748610230948918800296364184787, 68536318595052838310834810610435117143127088803068602445335475326427140828313, 71333662629967127822322169475282958517332768085026414016527475771426692311137, 71818789628596987832122424763592924131858666988566206124807910367000034628553, 72686903390659724206544737536831534683324964478965218565533472954938736006029, 73733187867854099083339033682720615801689502367745526033697746193463091215391, 74963435458999407861524268290816092282448161750409920047891056819453141955557, 75170120333127044486222669300167892338904422362667312672451826995740967131303, 75389546402724552962462061186170732933053151602764277596760332277139980288183, 76425604829327821607866318415668087016313389323090875428602763671306466213509, 79395489525333852455993920714320320052245084253382013156160044439065839468327, 79656464249999345933529538948250990091001499735972420522175125449790253663599, 80114644787477907454032975169773036722948929091396695518111556258640245353257, 80759006745106776887940527633196344281100618167707846074299752297932178679679, 82874221581479658193940394796733443765246468888210669340444752189895488345711, 84468817045619298841099296118053247701538652785316191917289525698631379587559, 85092225008500173289712181614303627906592443829912221851650912999596788670459, 85263141959763159396039844302970550543465193325499728803392808980592668472247, 85317220893586781914729151221061742320435924332561513947650447739620101821641, 85440269113801669657707134806659364077593365787015642755204798072592063745773, 85527879261087022928016922730880335213911499029647505445360684307006839178647, 85605932852710450456174796386471227136632343649286364769039469217779231567929, 86107819754589869545139506654865763056227887269808133233781131410193748463851, 86163843486640208219217644606617383296879865315755352427047957187159788303323, 90506049416840638351240993555664643907544570698557428055802715993870286417397, 90981593208992230235747480738729958015954461329514397574562251177250355618859, 94292491231252601103954494535972386523808989201770556967497120902651386194197, 94647786177270050686880223709072304737527824812798720504615370320158513996239, 95245024143291248356010627064844329722889005501412707859257139919568967846749, 96080930363425942206733690433078387012542225534990227081492087888246704507441, 97503025379673346416669602471064834261095444529417927406127397664552811080519, 97933089652660434994459543027801105444314465759238615625507952727940600189809, 97989967696425430412414365007330195727579540568089381507635553281304266294483, 98528881400840757343372680020873216862352604380253902505512625033610753437887, 99954243543097817759175467071884308315066389399425962144138323810271659014209, 101194437697606745792831239895049471075868629243259633705095039109106669730049, 104839585136982979038455371159792466832240349600316352323298553695087849421381, 105456177698115744366058226841117004148984862640508652026693415913601327156663, 105968680258458596148231537242426487615777154901757802179920828015643162453013, 107215231310505428676141499322854084705449980120508349014281658724461432400217, 108453510226000323101878638579711809016925129461454736081626840494612032349563, 108912309872075893365304953396355888979232521108447384367848671194555817947569, 108997022694208058790012872910875462503431062529475661062287324154956518493253, 109322568022936420513907683387388159609608845110397725890561824119551381299491, 110029910646386857435917200277309270534213159892118369614262345955187628998231, 113144116692201726589659464242284454643667198002480615110504233499994524508369, 114364819674774846158222033218389865879337160752260853195966728903452922982539, 115473149458023487534963694928189868221104180303262395583076896364124371580681]
c = 53630975642867707857977893429296334474716191527562307357222551886495223105860
ps = ps[::-1]

def find_flag(ct, i):
    if i == len(ps):
        return print(long_to_bytes(ct))
    roots = sp.sqrt_mod(ct, ps[i], all_roots=True)
    if roots != None:
        for r in roots:
            find_flag(r, i+1)
            
find_flag(c, 0)
```
Flag: *AKASEC{akasec+palestine=<3}*

## Twin
### Description:
I have a twin but he doesn't looks like me !!, so sad isn't !?

### Attachments:
*chal.py*
```python
from Crypto.Util.number import getPrime, bytes_to_long
from SECRET import FLAG

e = 5
p = getPrime(256)
q = getPrime(256)
n = p * q

m1 = bytes_to_long(FLAG)
m2 = m1 >> 8

if __name__ == "__main__":
    c1, c2 = pow(m1, e, n), pow(m2, e, n)
    print("n = {}\nc1 = {}\nc2 = {}".format(n, c1, c2))
```

*out.txt*
```
n = 6689395968128828819066313568755352659933786163958960509093076953387786003094796620023245908431378798689402141767913187865481890531897380982752646248371131
c1 = 3179086897466915481381271626207192941491642866779832228649829433228467288272857233211003674026630320370606056763863577418383068472502537763155844909495261
c2 = 6092690907728422411002652306266695413630015459295863614266882891010434275671526748292477694364341702119123311030726985363936486558916833174742155473021704
```

### Analysis:
Lại là một bài về RSA, lần này `e` vẫn tương đối nhỏ (e = 5). Đề bài cho ta biết `n` và mã hóa của `m1`, `m2` với `m1` chính là flag và `m2 = m1 >> 8`.

Ở đây thì `m2 = m1 >> 8` nghĩa là `m2` chính là `m1` nhưng bị mất đi 8-bits = 1-bytes cuối. Do `m1` là flag nên ta biết rằng byte cuối đó chính là `"}"`.

Với 2 ciphertext của 2 message mà ta đã biết một phần khác nhau nhất định, mình sẽ sử dụng **Franklin–Reiter related-message attack** để giải bài này.

### Solution:
> `f1 = x**e - c2` nên x sẽ là flag bị thiếu đi "}"
=>   `f2 = (2**(1*8) * x + ord("}"))**e - c1` (2^(1*8) * x chính là dịch trái 8-bits)

```python
from Crypto.Util.Padding import pad
from Crypto.Util.number import *
from sage.all import *

n = 6689395968128828819066313568755352659933786163958960509093076953387786003094796620023245908431378798689402141767913187865481890531897380982752646248371131
c1 = 3179086897466915481381271626207192941491642866779832228649829433228467288272857233211003674026630320370606056763863577418383068472502537763155844909495261
c2 = 6092690907728422411002652306266695413630015459295863614266882891010434275671526748292477694364341702119123311030726985363936486558916833174742155473021704
e = 5

pgcd = lambda g1, g2: g1.monic() if not g2 else pgcd(g2, g1%g2)

x = PolynomialRing(Zmod(n), 'x').gen()
f1 = x**e - c2
f2 = (2**(1*8) * x + ord("}"))**e - c1

g = int(-pgcd(f1, f2)[0])
print(long_to_bytes(g) + b'}')
```
Flag: *AKASEC{be_on_the_right_side_of_history_free_palestine}*

## GCL
### Description:
All about THEORIC and some LUCK.

### Attachments:
*chal.py*
```python
from random import getrandbits
from Crypto.Util.number import getPrime
from SECRET import FLAG

BITS = 128
m = getPrime(BITS)
s = getrandbits(BITS - 1)
a = getrandbits(BITS - 1)
b = getrandbits(BITS - 1)

def lcg(s, c):
    return c*(a*s + b) % m

if __name__ == "__main__":
    c = []
    r = s
    for i in FLAG:
        r = lcg(r, ord(i))
        c.append(r)
    print("m = {}\nc = {}".format(m, c))
```

*out.txt*
```
m = 188386979036435484879965008114174264991
c = [139973581469094519216727575374900351861, 72611500524424820710132508411012420565, 140250284171774823110472025667980956543, 32777758636601391326104783245836052689, 93866424818360655182957373584240082579, 171863599957625964609271128026424910780, 79519361871833866309751703823833758895, 157560014678333843523667019607330519198, 124975940725420603096426178838171348774, 3564693226938115115868719960412136082, 171740395033004244209129576880703758137, 92351702560499873288607191820522016910, 150094682983991168941275074808189562445, 85216665671310516224623100332845098274, 16595528649897543867800038656511154165, 19125026372283368463438507438570762609, 176795229245184227193627490600890111381, 12405536363393343486876802251851443164, 21411546298976790262184367895329536928, 182888536880153351183725282563493758721, 138117470020493616013148815568927291737, 32287599436436170232396368906599005001, 163785640221676961026807618948041121515, 73960913430365454320029097511676942987, 15454719718422589834477927328058381231, 187548967342452768771256903662911504220, 159561161576243464490176365717896800999, 68751190791869748062871941359673493536, 121231243784105483671509398006895458898, 14881767206744163076100305953646446453, 175267890044871169868897060667629218625, 147751087332703693307658387948934053643, 144192171120888146499506968416035431150]
```

### Analysis:
Đây là một bài về biến thể của **Linear Congruential Generator (LCG)**. Cụ thể, thay vì lấy `(a*s + b) % m`, ta có như sau:

```python
def lcg(s, c):
    return c*(a*s + b) % m
```

Với `c` chính là các kí tự của flag

```python
for i in FLAG:
        r = lcg(r, ord(i))
        c.append(r)
```

Tuy nhiên, cũng vì thế mà thuật toán này sẽ rất dễ bị phá nếu ta biết 3 kí tự đầu của flag là "AKA" và 3 ciphertext tương ứng. Ta sẽ có 3 phương trình như sau:

$$ c_0 = 65.(as + b) \pmod{m} $$  
$$ c_1 = 75.(ac_0 + b) \pmod{m} $$  
$$ c_2 = 65.(ac_1 + b) \pmod{m} $$

Từ phương trình (3), ta có thể rút ra a:

$$ a = (65^{-1}c_2 - b).c1^{-1} \pmod{m} $$

Từ phương trình (1) và (2), ta sẽ có được phương trình của b theo a:

$$ b = (75^{-1}c_1 - ac_0) \pmod{m} $$  

Thế vào phương trình số (3) ta sẽ có như sau:

$$ a = (65^{-1}c_2 - 75^{-1}c_1 + ac_0).c1^{-1} \pmod{m} $$  
$$  \Leftrightarrow a(c_1 - c_0) = (65^{-1}c_2 - 75^{-1}c_1) \pmod{m} $$  
$$  \Leftrightarrow a = (65^{-1}c_2 - 75^{-1}c_1)(c_1 - c_0)^{-1} \pmod{m} $$

Khi đã tính được `a`, ta sẽ thay ngược lại để tính `b`. Sau đó tính ra `s` bằng công thức sau:

$$ s = (65^{-1}c_0 - b).a^{-1} \pmod{m} $$ 

Có đủ `a`, `b` và `s`, ta chỉ cần bruteforce từng kí tự của flag, nếu hàm `lcg` này trả về giá trị đúng như trong mảng `c` thì đó là kí tự đúng.

### Solution:
```python
from Crypto.Util.number import *

m = 188386979036435484879965008114174264991
c = [139973581469094519216727575374900351861, 72611500524424820710132508411012420565, 140250284171774823110472025667980956543, 32777758636601391326104783245836052689, 93866424818360655182957373584240082579, 171863599957625964609271128026424910780, 79519361871833866309751703823833758895, 157560014678333843523667019607330519198, 124975940725420603096426178838171348774, 3564693226938115115868719960412136082, 171740395033004244209129576880703758137, 92351702560499873288607191820522016910, 150094682983991168941275074808189562445, 85216665671310516224623100332845098274, 16595528649897543867800038656511154165, 19125026372283368463438507438570762609,
     176795229245184227193627490600890111381, 12405536363393343486876802251851443164, 21411546298976790262184367895329536928, 182888536880153351183725282563493758721, 138117470020493616013148815568927291737, 32287599436436170232396368906599005001, 163785640221676961026807618948041121515, 73960913430365454320029097511676942987, 15454719718422589834477927328058381231, 187548967342452768771256903662911504220, 159561161576243464490176365717896800999, 68751190791869748062871941359673493536, 121231243784105483671509398006895458898, 14881767206744163076100305953646446453, 175267890044871169868897060667629218625, 147751087332703693307658387948934053643, 144192171120888146499506968416035431150]

x0 = c[0]
x1 = c[1]
x2 = c[2]

a = ((x2*inverse(ord('A'), m) - x1*inverse(ord('K'), m))*inverse(x1 - x0, m)) % m
b = (x1*inverse(ord('K'), m) - a*x0) % m
s = ((x0*inverse(ord('A'), m) - b)*inverse(a, m)) % m

def lcg(s, c):
    return c*(a*s + b) % m

p = []
r = s
for i in c:
    for j in range(33,126):
        if(lcg(r, j) == i):
            p.append(chr(j))
            r = lcg(r, j)
            break

flag = ''.join(p)
print(flag)
```
Flag: *AKASEC{++see_?!_just_some_math--}*

### Another solution:
Một cách giải khác là sử dụng `groebner_basis` trong vành hữu hạn. Ta sẽ có 8 đa thức từ 8 kí tự đã biết của flag form. Kỳ vọng của chúng ta là nó sẽ ra được các đa thức chỉ chứa `a` hoặc `b` luôn.

Mình sẽ sử dụng **sagemath**:
```python
P.<a,b> = PolynomialRing(Zmod(m), order='lex')
flag_form = 'AKASEC{'
eq = []
for i in range(1, 7):
    eq.append(ord(flag_form[i])*(a*ct[i-1] + b) - ct[i])
eq.append(ord('}')*(a*ct[31] + b) - ct[32])

I = ideal(eq)
print(I.groebner_basis())

# [a + 130507591207059696366651686185689099048, b + 65133415165202666396914997167577762424]
```
Từ đây mình có thể khôi phục lại `a`, `b` sử dụng:

```python 
a = -130507591207059696366651686185689099048 % m
b = -65133415165202666396914997167577762424 % m
```

Việc tính `s` vẫn sẽ giống như ban đầu, và ta sẽ có được flag.

### Another another solution:
Sử dụng ma trận
```python
# s -> CHAR * (a s + b) -> CHAR s a + CHAR b
# m, c = enc()

c0, c1, c2 = c[:3]
k1, k2 = [i for i in b'KA'] # since we know flag starts with AKASEC

# Solve system of equations using matrices
"""
c1 = K * c0 a + K * b
c2 = A * c1 a + A * b
"""
M = Matrix(Zmod(m), [[k1 * c0, k1], [k2 * c1, k2]])
v = vector(Zmod(m), [c1, c2])
a, b = [int(i) for i in M.solve_right(v)]
```

## My Calculus Lab
### Description:
We share a secret key between us in the calculus lab, We hope no outsider could get to it :)

And never forget: #FreePalestine 🇵🇸

### Attachments:
*chal.py*
```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
import hashlib
import sympy as sp
import random

FLAG = b'REDACTED'

key = random.getrandbits(7)

x = sp.symbols('x')

f = "REDACTED"
f_prime = "REDACTED"
f_second_prime = "REDACTED"

assert(2*f_second_prime - 6*f_prime + 3*f == 0)
assert(f.subs(x, 0) | f_prime.subs(x, 0) == 14)

def encrypt(message, key):
    global f
    global x
    point = f.subs(x, key).evalf(100)
    point_hash = hashlib.sha256(str(point).encode()).digest()[:16]
    cipher = AES.new(point_hash, AES.MODE_CBC)
    iv = cipher.iv
    ciphertext = cipher.encrypt(pad(message, AES.block_size))
    return iv.hex() + ciphertext.hex()

encrypted = encrypt(FLAG, key)

print(f"Key: {key}")
print(f"Encrypted: {encrypted}")
```

*enc.txt*
```
Key: 60
Encrypted: 805534c14e694348a67da0d75165623cf603c2a98405b34fe3ba8752ce24f5040c39873ec2150a61591b233490449b8b7bedaf83aa9d4b57d6469cd3f78fdf55
```

### Analysis:
Bài này yêu cầu chúng ta phải giải một phương trình vi phân cấp hai thuần nhất:

$$ 2f''(x) - 6f'(x) + 3f(x) = 0 $$ 

Để giải phương trình này, ta sẽ đặt như sau:

$$ f(x) = e^{rt} $$  
$$ \Leftrightarrow f'(x) = re^{rt} $$  
$$ \Leftrightarrow f''(x) = r^{2}e^{rt} $$  

Khi đó phương trình vi phân của ta sẽ trở thành:

$$ 2r^{2}e^{rt} - 6re^{rt} + 3e^{rt} = 0 $$ 
$$ \Leftrightarrow 2r^{2} - 6r + 3 = 0 $$
$$ \Leftrightarrow r = \frac{3 \pm \sqrt{3}}{2} $$  

Vậy phương trình cần tìm của ta sẽ có dạng:

$$ f(x) = C_1e^{\frac{3 + \sqrt{3}}{2}} + C_2e^{\frac{3 - \sqrt{3}}{2}} $$  

Giờ để tìm ra C1 và C2, mình sẽ dựa vào điều kiện còn lại là:

$$ f(0) | f'(0) = 14 $$

Vì là OR nên 2 giá trị này chỉ có thể là các số nguyên không âm. Vì vậy mình có thể bruteforce 2 giá trị này và thay vào để tìm ra C1, C2. Đoạn sau thì tương đối đơn giản:

```python
def encrypt(message, key):
    global f
    global x
    point = f.subs(x, key).evalf(100)
    point_hash = hashlib.sha256(str(point).encode()).digest()[:16]
    cipher = AES.new(point_hash, AES.MODE_CBC)
    iv = cipher.iv
    ciphertext = cipher.encrypt(pad(message, AES.block_size))
    return iv.hex() + ciphertext.hex()
```

Chỉ cần phương trình f(x) đúng thì ta sẽ có được key = SHA256 của điểm f(60). Sử dụng key này và iv được cho, ta sẽ giải mã được ciphertext.

### Solution:
> Mình có kiếm được hàm `generate_or_number` để có thể tạo ra các tập số mà khi đem OR có thể ra được 14 sử dụng phương pháp phân tích bit. Dù chưa hiểu thuật toán lắm nhưng sure là nó sẽ nhanh hơn là phải bruteforce và cho if i OR j == 14.

```python
import sympy as sp
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import hashlib

key = 60
c = "805534c14e694348a67da0d75165623cf603c2a98405b34fe3ba8752ce24f5040c39873ec2150a61591b233490449b8b7bedaf83aa9d4b57d6469cd3f78fdf55"

def generate_or_number(target):
    bits = [1 << i for i in range(target.bit_length()) if (target & (1 << i)) != 0]
    result = set()
    from itertools import combinations
    for r in range(1, len(bits) + 1):
        for combo in combinations(bits, r):
            result.add(sum(combo))
    return sorted(result)

def decrypt(encrypted, key):
    global f
    global x

    iv = bytes.fromhex(encrypted[:32])
    ciphertext = bytes.fromhex(encrypted[32:])

    point = f.subs(x, key).evalf(100)
    point_hash = hashlib.sha256(str(point).encode()).digest()[:16]

    cipher = AES.new(point_hash, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)
    return plaintext

num = generate_or_number(14)

for i in num:
    for j in num:
            x = sp.symbols('x')
            f = sp.Function('f')(x)

            diff_eq = sp.Eq(2 * f.diff(x, x) - 6 * f.diff(x) + 3 * f, 0)
            initial_conditions = {f.subs(x, 0): i, f.diff(x).subs(x, 0): j}

            solution = sp.dsolve(diff_eq, f, ics=initial_conditions)
            f = solution.rhs

            flag = decrypt(c, key)
            if b'AKASEC{' in flag:
                print(unpad(flag, AES.block_size))
```
Flag: *AKASEC{d1d_y0u_3nj0y_c41cu1u5_101?}*

## Magic
### Description:
All you get is the connection you have.

`nc 20.80.240.190 4455`

### Analysis:
Một bài Crypto Whitebox. Giao diện khi mình netcat sẽ kiểu như này:

```shell
n = 124858453996774455175831237388783456398873494792971534641906593064537398606270863687615782631563971824220106303414117271215470665630424707020365712474872798752936619693658594537474951526449646751480630953832851092088734049143563437606303122506401788268787791664153473572604493281992887617340576760054562144297
e = 65537

give your magic number: 1
c = 54739498014692963670739255550344626839445909610063788802683284026293460826482290173768557045615462186610937675965434695533690448343063180587058949839814986540261450067227916997341400495137845218409544388160751581358971277285247630794369080577276575925690991671623026071614843923134539883727934573958033023385
give your magic number: 2
c = 118563924084288350979875911826911648451492417410190442729605150398990172742114706881713513260026456606361974691958281592863308845429539916753212690715752514045536515126148415165012770596068180597350731418026863309021787875428315105983955850026374009526923946370126032394401959157207131917483677062468325010139
give your magic number: a
Are sure about that ...
```

Chương trình sẽ cho chúng ta biết `n`, `e`, có vẻ đây là một bài RSA. Ứng với mỗi một "magic number", chương trình sẽ trả về cho ta một ciphertext. "Magic number" này cũng chỉ được phép là số.

Khi thử một số to, mình nhận thấy kết quả đều trả về c = 0, cho tới khi mình thử với số 302 thì nó trả về c = 1:

```shell
give your magic number: 9999
c = 0
give your magic number: 500
c = 0
give your magic number: 400
c = 0
give your magic number: 302
c = 1
give your magic number: 303
c = 0
give your magic number: 301
c = 72592243079603522342723072993871394189245725180498884385863982114511838189853009543721573492376155248328952188516016422657555215043864179687970092202705626295576941426682185514867524107348572559147337091889285885078737999247938685841077300540341929945354748124529558959257545661913342915494168681418868293887
```

Đến đây thì mình đoán được khi "magic number" là 302 thì m = 1 hoặc e = 0 thì mới tạo ra c như vậy được. Cho tới khi mình thử với một số âm

```shell
give your magic number: -1
can't shif... Nevermind
```

Đến đây thì mình cũng đoán ra được nó sử dụng bit shift số "magic number" sau đó in ra ciphertext. Ứng với giả thuyết m = 1 hoặc e = 0 thì mình đoán ciphertext sẽ có dạng:

$$ c = (m >> 302)^e \pmod{n} $$  

Có nghĩa là `m` sẽ là một số nguyên 303-bits. Vậy mình sẽ bruteforce từng kí tự của `m` bằng cách gửi lần lượt magic number giảm dần. Cụ thể:

$$ m >> 302 = 1 $$  
$$ \Leftrightarrow \left[ \begin{array}{l}m >> 301 = 10 \\ m >> 301 = 11 \end{array} \right. $$  

Tương tự với các bit còn lại. Nếu m >> 301 = 10 thì m >> 300 = 100 hoặc m >> 300 = 101. Việc chọn ra được cái nào sẽ được tính bằng cách so sánh với c trả về.

### Solution:
```python
from pwn import *
from Crypto.Util.number import *
from tqdm import tqdm

conn = remote('20.80.240.190', 4455)

n = int(conn.recvline().decode().strip()[3:])
e = int(conn.recvline().decode().strip()[3:])
print("n = ", n)
print("e = ", e)
conn.recvline()

bits = "1"
for i in tqdm(range(301, -1, -1)):
    zero = int(bits + '0', 2)
    one = int(bits + '1',2)

    conn.sendline(str(i).encode())
    c = int(conn.recvline().decode().strip()[28:])
    
    if(pow(zero, e, n) == c):
        bits += '0'
    else:
        bits += '1'

print(bits)

flag = long_to_bytes(int(bits, 2))
print(flag)
```
Flag: *AKASEC{7alawa_ayayay_tbt_m3ana_asa7bi}*

## DODOLOUF
### Description:
This was supposed to be the warmup challenge.

`nc 20.80.240.190 4447`

### Attachment:
*Chall.py*
```python
from os import urandom
from random import getrandbits
from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes
from Crypto.Util.Padding import pad
import pickle
import time

def generate_number(bits):
    return getrandbits(bits)

class myencryption():
    def __init__(self):
        self.key_counter = 0
        self.encryptions_count = 0
        self.still_single = True
        self.keys = []
        self.username = ""
        self.iv = urandom(16)

    def generate_key(self):
        key = getrandbits(128)
        return long_to_bytes(key)

    def get_recognizer(self):
        self.recognizer = {"id": int(time.time()) * 0xff, "username": self.username, "is_admin": False, "key": self.keys[self.key_counter].hex()}

    def encrypt(self):
        key = self.generate_key()
        self.keys.append(key)
        self.encryptions_count += 1
        self.get_recognizer()
        cipher = AES.new(key, AES.MODE_CBC, iv=self.iv)
        return cipher.encrypt(pad(pickle.dumps(self.recognizer), 16))

    def decrypt(self, data):
        key = self.keys[self.key_counter]
        cipher = AES.new(key, AES.MODE_CBC, iv=self.iv)
        return pickle.loads(cipher.decrypt(data))

header = "=========================================================================================="

def logs(cipher):
    print("Welcome to your inbox !")
    print("---> You have 1 message <---")
    print(f"---> You have encrypted a text {cipher.encryptions_count} times.")
    print(f"---> Unfortunatly you are still single." if cipher.still_single else "You are in a relationship.")
    print(f"---> The current key that was used to encrypt is {cipher.keys[cipher.key_counter].hex()}.")
    print("Thank you for using our service !")

def main():
    cipher = myencryption()
    cipher.username = input("What can I call you ? ")
    print("IV used during this session: ", cipher.iv.hex())
    print(header)
    while True:
        token = cipher.encrypt()
        print("Your new token is : ", token.hex())
        print("Menu:\n1. Logs\n2. Get Flag\n3. Exit")
        choice = int(input("Enter your choice: "))
        if choice == 1:
            session_id = bytes.fromhex(input("Would you kindly input your session id: "))
            cipher.iv = session_id[:16]
            decrypted_token = cipher.decrypt(session_id[16:])
            if decrypted_token['is_admin'] == True:
                logs(cipher)
            else:
                print("My apologies, but this is reserved for the admins only.")
        elif choice == 2:
            print("In order to get the flag, you must prove that you are the admin.")
            your_bet = input("What is the key that I'm going to use next ?")
            if your_bet == cipher.generate_key().hex():
                print("Congratulation ! Here is the flag: AKASEC{nn_hh}")
            else:
                print("I am sorry, but you are not the admin.")
                exit()
        elif choice == 3:
            exit()
        else:
            print("Invalid choice. Please try again.")
        cipher.key_counter += 1

if __name__ == "__main__":
    main()
```

### Analysis:


### Solution:

## BOSS LEVEL
### Description:
This challenge is based on Cryptanalysis.

It's time for you to know if you really like crypto, or you just good at it.

It's time to know if you're a follower.

And why do Cryptanalysis gets so much hate ?

Good luck to you all !

`nc 20.80.240.190 4446`

> Hint: "The alphabet used is : REDABCFGHIJKLMNOPQSTUVWXYZ"

### Attachment:
*Ciphertext*
```
VMQPEQWTTUUWENDRTJXPHLLQGAUPIDEQRDYAMJLFVUNLGSNZFUUNS.TFR,EKJOOQSERQGKOFWLQOYWLGGPOYWOFVEEIACTKDEGQHRH'BOGYMSCSIGC.VJUJQSOCRDEBVWMFLSQS,FRUDEOGVALWXPGAVFR.PAHCOCGSG,IQMFLSNGJMFUIQZLEFIAEWLRZRLF,DFVKDXVZFPBUE;FSFGTKCXZKHRDDOKSYBWIF.ICGTTDXYLRZELFRVQRWEXUJQVTEQUCQBHDWGV,HGTUXUJWGXEJGKOKUEADBQVGMHBVUELCOHSR'KGJOH.ZM'SUDWGPVUVVOKKVBVIOUSSRDEGVAJ,CWX.DVTFSIYFGSLHCLTG.ZMRWBOUSTSULGDFL.FHPNGFCUUZNGVBEHX.ARATSULGDFL'JWEBOAVKMLRDFL...GMIVFBOKVJBFBBJDYDOVELTVXEBB.NU'BOIOYWUJDFFVJUKAUWMBUBXYLEFLYSGOVTNJGNFCGGJPIEHT'VLRSGMCDVROSRVDIOY,FRUFYIOBTGVE,QUCLGYUFZFLJ.XAGDBHGG'D.QUCHT'TJFSSHBQVOIAREGPGNFCYWNG.IQNNU'IOEBLP,NJNBTVJKJPVIS.OVFTGOOVF?KQQL'CKWSVODHU.CWQOXNJPUSQUJUHMXFJGEWWZLDVPOVSDKFKFYGENH?WAGVDIJSGFPEKJNOVIKQOTFPTKOYWREYDDCLVEOVGYGXGENMGXFUBDTXTUDNVEOTWIJYUYPDJLRCWWAE?ATIPTDWUMQKEGURRYIAFPWLXPUTQFJPZNIBSDRWWJSPURI?KQQLAISQQICIMJNQFPEXVDEVPVXZNLGSRKOXNXGHFPEEAGNVGWOGF.ERLGD'RYVIGHTKHAMSZI.GXOLVKKSTWEWTSGENHLXPUMRKLDVEXSSDZZDTXTU.HHTTASEPFWAOUDEECLLISNOKWAGOHEFWLIIAUATIEEHMHNOOHCULLMTHLOWAOYNIHUSTLOIGGLWOWIIWMRI.IOIROK.DYYOYSWSTSUIIDHNEPYOAVFTAL.
```

### Analysis:

### Solution:
