---
title: ImaginaryCTF 2024
description: CTF-Crypto
author: Pr0pylTh10ur4C1L
date: 2024-07-23 17:58:00 +0700
categories: [Capture The Flag]
tags: [Cryptography]
math: true
mermaid: true
media_subpath: /assets/img/2024-07-23-imaginary-ctf-2024/
---

## base64
### Description:
yet another base64 decoding challenge

### Attachments:
*main.py*
```python
from Crypto.Util.number import bytes_to_long

q = 64

flag = open("flag.txt", "rb").read()
flag_int = bytes_to_long(flag)

secret_key = []
while flag_int:
    secret_key.append(flag_int % q)
    flag_int //= q

print(f"{secret_key = }")
```

*out.txt*
```
secret_key = [10, 52, 23, 14, 52, 16, 3, 14, 37, 37, 3, 25, 50, 32, 19, 14, 48, 32, 35, 13, 54, 12, 35, 12, 31, 29, 7, 29, 38, 61, 37, 27, 47, 5, 51, 28, 50, 13, 35, 29, 46, 1, 51, 24, 31, 21, 54, 28, 52, 8, 54, 30, 38, 17, 55, 24, 41, 1]
```

*sbg.png*  
![sbg](sbg.png)

### Analysis:
Với bài này, flag sẽ được mã hóa bằng cách chuyển từ bytes về số nguyên, sau đó tiến hành:
- Tính $ \text{flag_int} \pmod{q} $ và thêm vào `secret_key`
- Lấy $\text{flag_int} = \text{flag_int} // q$

Có thể thấy, phép tính đầu sẽ tính ra số dư của phép chia flag với q, và phép tính thứ 2 sẽ tính ra thương của chúng. Ta có công thức sau từ hồi học Tiểu Học:

$$ D=d×q+r $$

Với:
- $D$: dividend (số bị chia)
- $d$: divisor (số chia)
- $q$: quotient (thương)
- $r$: remainder (số dư)

Vòng lặp `while flag_int` cho thấy nó sẽ lặp tới khi chia hết hay `flag_int == 0`. Vậy ta đã biết thương cuối cùng (giả sử là lần thứ n) là 0, số chia là 64, số dư là 1. Ta sẽ tính được số bị chia là thương thứ n-1 hay `flag_int` sau khi bị chia n-1 lần. Cứ thế, ta sẽ khôi phục được `flag_int` ban đầu.

### Solution:
```python
from Crypto.Util.number import *

secret_key = [10, 52, 23, 14, 52, 16, 3, 14, 37, 37, 3, 25, 50, 32, 19, 14, 48, 32, 35, 13, 54, 12, 35, 12, 31, 29, 7, 29, 38, 61, 37, 27, 47, 5, 51, 28, 50, 13, 35, 29, 46, 1, 51, 24, 31, 21, 54, 28, 52, 8, 54, 30, 38, 17, 55, 24, 41, 1]
secret_key = secret_key[::-1]


q = 64
flag_int = 0

for remainder in secret_key:
    flag_int = flag_int*q + remainder

flag = long_to_bytes(flag_int).decode().strip()
print(flag)
```

Flag: *ictf{b4se_c0nv3rs1on_ftw_236680982d9e8449}*

### Bonus:
Mình đã dựa vào kiến thức Tiểu Học, nhưng dựa vào bức ảnh ở attachments, mình cũng nhận ra đây chính là base conversion. Cụ thể là ta đang chuyển tự hệ thập phân về hệ 64. Vì vậy, ta có thể khôi phục lại nó sử dụng công thức:

$$ \text{Decima Value} = \sum_{i=0}^{n-1} (\text{Digit}_i \times \text{Base}^i) $$
> Nên nhớ là công thức trên nếu đã reverse kết quả để lấy số hoàn chỉnh rồi thì phải đảo ngược lại. Xem cách chuyển từ 10->2 và 2->10 sẽ hiểu ý.

```python
from Crypto.Util.number import *

secret_key = [10, 52, 23, 14, 52, 16, 3, 14, 37, 37, 3, 25, 50, 32, 19, 14, 48, 32, 35, 13, 54, 12, 35, 12, 31, 29, 7, 29, 38, 61, 37, 27, 47, 5, 51, 28, 50, 13, 35, 29, 46, 1, 51, 24, 31, 21, 54, 28, 52, 8, 54, 30, 38, 17, 55, 24, 41, 1]

q = 64

flag_int = 0
for i, digit in enumerate(secret_key):
    flag_int += digit * (q ** i)

flag = long_to_bytes(flag_int).decode().strip()
print(flag)

# ictf{b4se_c0nv3rs1on_ftw_236680982d9e8449}
```

## integrity
### Description:
I think this is how signing works

### Attachments:
*main.py*
```python
from Crypto.Util.number import *
from binascii import crc_hqx

p = getPrime(1024)
q = getPrime(1024)

n = p*q
e = 65537
tot = (p-1)*(q-1)
d = pow(e, -1, tot)

flag = bytes_to_long(open("flag.txt", "rb").read())
ct = pow(flag, e, n)

#signature = pow(flag, d, n) # no, im not gonna do that
signature = pow(flag, crc_hqx(long_to_bytes(d), 42), n)

print(f"{n = }")
print(f"{ct = }")
print(f"{signature = }")
```

*out.txt*
```
n = 10564138776494961592014999649037456550575382342808603854749436027195501416732462075688995673939606183123561300630136824493064895936898026009104455605012656112227514866064565891419378050994219942479391748895230609700734689313646635542548646360048189895973084184133523557171393285803689091414097848899969143402526024074373298517865298596472709363144493360685098579242747286374667924925824418993057439374115204031395552316508548814416927671149296240291698782267318342722947218349127747750102113632548814928601458613079803549610741586798881477552743114563683288557678332273321812700473448697037721641398720563971130513427
ct = 5685838967285159794461558605064371935808577614537313517284872621759307511347345423871842021807700909863051421914284950799996213898176050217224786145143140975344971261417973880450295037249939267766501584938352751867637557804915469126317036843468486184370942095487311164578774645833237405496719950503828620690989386907444502047313980230616203027489995981547158652987398852111476068995568458186611338656551345081778531948372680570310816660042320141526741353831184185543912246698661338162113076490444675190068440073174561918199812094602565237320537343578057719268260605714741395310334777911253328561527664394607785811735
signature = 1275844821761484983821340844185575393419792337993640612766980471786977428905226540853335720384123385452029977656072418163973282187758615881752669563780394774633730989087558776171213164303749873793794423254467399925071664163215290516803252776553092090878851242467651143197066297392861056333834850421091466941338571527809879833005764896187139966615733057849199417410243212949781433565368562991243818187206912462908282367755241374542822443478131348101833178421826523712810049110209083887706516764828471192354631913614281317137232427617291828563280573927573115346417103439835614082100305586578385614623425362545483289428
```

### Analysis:
Bài này là một bài RSA easy. Ở đây mình có 2 giá trị `ct` và `signature` được tính bằng công thức:

$$ ct \equiv flag^e \pmod{n} $$

$$ signature \equiv flag^y \pmod{n} $$

Do ta có cùng `e` và `flag`, đây là dạng **Common Modulus** (Chi tiết xem thêm [link](https://drx.home.blog/2019/03/01/crypto-rsa/)). Vậy việc cần làm là phải tính giá trị `y`, hay `crc_hqx(long_to_bytes(d),42)`.

Dựa trên thông tin mình tra được của thư viện *binascii* thì hàm này trả về CRC-16 của dữ liệu đưa vào, cùng với đó cho phép chỉ định một giá trị khởi đầu (ở đây là 42).

Do là CRC-16 hay nó sẽ là 1 số 16-bit nên nó chỉ trong khoảng từ 0-65535, dễ dàng bruteforce. Để cho không phải tiến hành tấn công với mỗi số thì mình sẽ tìm số `y` này bằng cách lấy lũy thừa `y` của `ct`. Khi đó ta có:

$$ ct^y \equiv  flag^{ye} \pmod{n} $$

$$ \Leftrightarrow ct^y \equiv signature^e \pmod{n} $$

Bruteforce công thức trên để tìm `y` sẽ nhanh hơn chút so với việc tiến hành tấn công Common Modulus mỗi lần

### Solution:
```python
from sage.all import *
from Crypto.Util.number import *

def attack(C1, C2, e1, e2, N):
    _, x, y = xgcd(e1, e2)
    m = (pow(C1, x, N) * pow(C2, y, N)) % N
    return m

n = 10564138776494961592014999649037456550575382342808603854749436027195501416732462075688995673939606183123561300630136824493064895936898026009104455605012656112227514866064565891419378050994219942479391748895230609700734689313646635542548646360048189895973084184133523557171393285803689091414097848899969143402526024074373298517865298596472709363144493360685098579242747286374667924925824418993057439374115204031395552316508548814416927671149296240291698782267318342722947218349127747750102113632548814928601458613079803549610741586798881477552743114563683288557678332273321812700473448697037721641398720563971130513427
ct = 5685838967285159794461558605064371935808577614537313517284872621759307511347345423871842021807700909863051421914284950799996213898176050217224786145143140975344971261417973880450295037249939267766501584938352751867637557804915469126317036843468486184370942095487311164578774645833237405496719950503828620690989386907444502047313980230616203027489995981547158652987398852111476068995568458186611338656551345081778531948372680570310816660042320141526741353831184185543912246698661338162113076490444675190068440073174561918199812094602565237320537343578057719268260605714741395310334777911253328561527664394607785811735
signature = 1275844821761484983821340844185575393419792337993640612766980471786977428905226540853335720384123385452029977656072418163973282187758615881752669563780394774633730989087558776171213164303749873793794423254467399925071664163215290516803252776553092090878851242467651143197066297392861056333834850421091466941338571527809879833005764896187139966615733057849199417410243212949781433565368562991243818187206912462908282367755241374542822443478131348101833178421826523712810049110209083887706516764828471192354631913614281317137232427617291828563280573927573115346417103439835614082100305586578385614623425362545483289428
e = 65537

y = 0
for i in range(65536):
    if pow(ct, i, n) == pow(signature, e, n):
        y = i
        break

flag = attack(ct, signature, e, y, n)
flag = long_to_bytes(int(flag)).decode().strip()

print(flag)
```

Flag: *ictf{oops_i_leaked_some_info}*

